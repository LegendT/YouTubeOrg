---
phase: 08-batch-sync-operations
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/lib/sync/preview.ts
  - src/lib/sync/engine.ts
  - src/lib/sync/stages.ts
autonomous: true

must_haves:
  truths:
    - "computeSyncPreview returns accurate counts of playlists to create, videos to add, and playlists to delete with correct quota costs"
    - "Sync engine creates a job in pending state, transitions through stages in order: backup -> create_playlists -> add_videos -> delete_playlists -> completed"
    - "Engine pauses with reason 'quota_exhausted' when getRemainingQuota() returns less than 1000"
    - "create_playlists stage skips categories that already have a youtubePlaylistId (idempotent resume)"
    - "add_videos stage skips syncVideoOperations already marked completed (idempotent resume)"
    - "delete_playlists stage skips playlists already marked with deletedFromYoutubeAt (idempotent resume)"
    - "404 errors on playlist delete are treated as success"
    - "All errors during a stage are collected into the job's errors array, not thrown"
  artifacts:
    - path: "src/lib/sync/preview.ts"
      provides: "computeSyncPreview function"
      exports: ["computeSyncPreview"]
    - path: "src/lib/sync/engine.ts"
      provides: "Sync state machine orchestrator"
      exports: ["createSyncJob", "processSyncBatch", "pauseSyncJob", "resumeSyncJob", "getCurrentSyncJob"]
    - path: "src/lib/sync/stages.ts"
      provides: "Stage executor functions for create_playlists, add_videos, delete_playlists"
      exports: ["executeCreatePlaylists", "executeAddVideos", "executeDeletePlaylists"]
  key_links:
    - from: "src/lib/sync/engine.ts"
      to: "src/lib/sync/stages.ts"
      via: "stage executor imports"
      pattern: "import.*execute.*stages"
    - from: "src/lib/sync/stages.ts"
      to: "src/lib/youtube/write-operations.ts"
      via: "YouTube API write calls"
      pattern: "import.*createYouTubePlaylist.*write-operations"
    - from: "src/lib/sync/engine.ts"
      to: "src/lib/youtube/quota.ts"
      via: "getRemainingQuota for quota pause check"
      pattern: "import.*getRemainingQuota.*quota"
    - from: "src/lib/sync/preview.ts"
      to: "src/lib/db/schema.ts"
      via: "Query categories, categoryVideos, playlists tables"
      pattern: "import.*categories.*schema"
---

<objective>
Build the sync engine core: preview computation, state machine orchestrator, and stage executors.

Purpose: This is the heart of Phase 8. The preview tells the user exactly what will happen and how long it will take. The engine orchestrates the multi-day sync with stage transitions, quota awareness, and error collection. The stage executors perform the actual YouTube API operations with idempotent resume.

Output: 3 files in src/lib/sync/ providing the complete backend sync pipeline.
</objective>

<execution_context>
@/Users/anthonygeorge/.claude/get-shit-done/workflows/execute-plan.md
@/Users/anthonygeorge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/08-batch-sync-operations/08-RESEARCH.md
@.planning/phases/08-batch-sync-operations/08-CONTEXT.md
@.planning/phases/08-batch-sync-operations/08-01-SUMMARY.md
@src/lib/db/schema.ts
@src/lib/youtube/write-operations.ts
@src/lib/youtube/quota.ts
@src/lib/rate-limiter.ts
@src/lib/backup/snapshot.ts
@src/types/sync.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Sync preview computation and engine core</name>
  <files>src/lib/sync/preview.ts, src/lib/sync/engine.ts</files>
  <action>
**Create `src/lib/sync/preview.ts`:**

Export `computeSyncPreview(): Promise<SyncPreview>`:

1. **Count playlists to create:** Query `categories` WHERE `isProtected = false` AND `youtubePlaylistId IS NULL`. These are categories that need YouTube playlists. Each costs 50 units (playlists.insert). Return category names and IDs in the `items` array.

2. **Count video assignments:** Query `categoryVideos` JOIN `categories` WHERE `categories.isProtected = false`. Group by categoryId to get per-category video counts. Each assignment costs 50 units (playlistItems.insert). Return as `byCategory` array with categoryName, categoryId, videoCount.

3. **Count playlists to delete:** Query `playlists` WHERE `deletedFromYoutubeAt IS NULL`. Each costs 50 units (playlists.delete). Return playlist names, IDs, and youtubeIds in the `items` array.

4. **Calculate totals:**
   - `totalQuotaCost = createCost + addCost + deleteCost`
   - `estimatedDays = Math.ceil(totalQuotaCost / 10000)` (daily limit)
   - `dailyQuotaLimit = 10000`

5. Return `SyncPreview` object matching the type from `src/types/sync.ts`.

Import `db` from `@/lib/db`, `categories, categoryVideos, playlists` from `@/lib/db/schema`, `eq, isNull, count, sql` from `drizzle-orm`, `QUOTA_COSTS` from `@/lib/youtube/quota`, and `SyncPreview` from `@/types/sync`.

**Create `src/lib/sync/engine.ts`:**

This is the state machine orchestrator. Export the following functions:

1. `getCurrentSyncJob(): Promise<SyncJobRecord | null>`
   - Query `syncJobs` table ordered by `startedAt DESC LIMIT 1`
   - Return null if no jobs exist or latest job is `completed`/`failed`
   - Cast JSONB fields (stageResults, errors, previewData) to their TypeScript types

2. `createSyncJob(preview: SyncPreview): Promise<SyncJobRecord>`
   - Check no active job exists (getCurrentSyncJob returns null or completed/failed)
   - Insert into `syncJobs` with stage='pending', previewData=preview
   - Return the created job record

3. `processSyncBatch(accessToken: string, batchSize: number = 10): Promise<SyncJobRecord>`
   - Get current sync job. If null or completed/paused/failed, return it unchanged.
   - **Quota check:** Call `getRemainingQuota()`. If < 1000, call `pauseSyncJob(job.id, 'quota_exhausted')` and return.
   - **Stage routing:** Based on `job.stage`:
     - `pending` -> advance to `backup` stage
     - `backup` -> call `createSnapshot('pre_sync')` from backup module, store backupSnapshotId on job, advance to `create_playlists`
     - `create_playlists` -> call `executeCreatePlaylists(job, accessToken, batchSize)` from stages.ts
     - `add_videos` -> call `executeAddVideos(job, accessToken, batchSize)` from stages.ts
     - `delete_playlists` -> call `executeDeletePlaylists(job, accessToken, batchSize)` from stages.ts
   - Return updated job record

4. `advanceStage(jobId: number, nextStage: SyncStage): Promise<void>`
   - Update syncJobs SET stage=nextStage, currentStageProgress=0, currentStageTotal=0
   - If nextStage is 'completed', set completedAt=now

5. `pauseSyncJob(jobId: number, reason: PauseReason): Promise<SyncJobRecord>`
   - Update syncJobs SET stage='paused', pauseReason=reason
   - Return updated job

6. `resumeSyncJob(jobId: number): Promise<SyncJobRecord>`
   - Get job by ID. Verify stage is 'paused'.
   - Determine which stage to resume based on stageResults:
     - If create_playlists has results but add_videos doesn't -> resume at add_videos
     - If add_videos has results but delete_playlists doesn't -> resume at delete_playlists
     - Otherwise resume at the stage that was active when paused (stored in stageResults keys)
   - Actually: simpler approach -- store the stage that was active before pausing. On pause, save the real stage in a way that resume can restore it. Use a convention: when pausing from stage X, set `pauseReason` and `stage='paused'`. On resume, look at `stageResults` to find the last incomplete stage.
   - Better: add a `pausedAtStage` field to the pauseSyncJob logic. Store the current stage before changing to 'paused'. On resume, restore that stage.
   - Implementation: In `pauseSyncJob`, before setting stage='paused', record the current stage in stageResults metadata or a dedicated approach. Simplest: store it in the errors array as a system message, or add it to stageResults as `_pausedAtStage`. Actually simplest: just store the previous stage in `pauseReason` as `'quota_exhausted:add_videos'`. No -- keep it clean. Store in stageResults: `stageResults._meta = { pausedAtStage: 'add_videos' }`.
   - **Final approach:** When pausing, update job with `stage='paused'` but store the real stage in `stageResults._pausedAtStage`. When resuming, read `stageResults._pausedAtStage` and set stage back to that value. Update lastResumedAt. Clear pauseReason.
   - Return updated job

7. `updateJobProgress(jobId: number, progress: number, total: number, quotaUsed?: number): Promise<void>`
   - Update syncJobs SET currentStageProgress=progress, currentStageTotal=total
   - If quotaUsed provided, increment quotaUsedThisSync

8. `recordJobError(jobId: number, error: SyncError): Promise<void>`
   - Read current errors array, append new error, update job

9. `updateStageResults(jobId: number, stage: string, results: { succeeded: number; failed: number; skipped: number }): Promise<void>`
   - Read current stageResults, set stageResults[stage] = results, update job

Import from `@/lib/db`, schema tables, `getRemainingQuota` from `@/lib/youtube/quota`, `createSnapshot` from `@/lib/backup/snapshot`, types from `@/types/sync`, stage executors from `./stages`.

**IMPORTANT implementation notes:**
- Use `Number()` wrapper on any PostgreSQL bigint/aggregate results (project convention)
- JSONB fields from DB need type assertions when reading
- The `processSyncBatch` function is designed to be called repeatedly by the client (fire-and-process pattern). Each call processes up to `batchSize` operations and returns. The client polls and calls again.
- Quota check happens BEFORE each batch, not per-operation. This is acceptable because batchSize is small (10) and each op costs 50 units = 500 max per batch.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `grep -r "computeSyncPreview" src/lib/sync/preview.ts` shows the export
3. `grep -r "createSyncJob\|processSyncBatch\|pauseSyncJob\|resumeSyncJob\|getCurrentSyncJob" src/lib/sync/engine.ts` shows all exports
  </verify>
  <done>computeSyncPreview returns accurate quota estimates. Engine manages sync job lifecycle with stage transitions, quota-aware pausing, and resume capability.</done>
</task>

<task type="auto">
  <name>Task 2: Stage executors with idempotent resume</name>
  <files>src/lib/sync/stages.ts</files>
  <action>
**Create `src/lib/sync/stages.ts`:**

Export three stage executor functions. Each processes up to `batchSize` operations and returns, allowing the engine to check quota and update progress between batches.

1. `executeCreatePlaylists(job: SyncJobRecord, accessToken: string, batchSize: number): Promise<void>`
   - Query categories WHERE `isProtected = false` AND `youtubePlaylistId IS NULL` (not yet created)
   - If none remain, record stageResults for create_playlists and call `advanceStage(job.id, 'add_videos')`. Before advancing, populate the syncVideoOperations table: query all categoryVideos for non-protected categories, insert one syncVideoOperation row per (categoryId, videoId) pair with status='pending'. Include youtubeVideoId by joining to videos table.
   - Process up to `batchSize` categories:
     - Call `createYouTubePlaylist(accessToken, category.name)` from write-operations.ts
     - On success: update `categories` SET `youtubePlaylistId = returnedId`
     - On error: check error type:
       - 403 quotaExceeded -> call engine `pauseSyncJob(job.id, 'quota_exhausted')`, return immediately
       - 429 -> already handled by Bottleneck retry in rate-limiter.ts (will retry automatically)
       - Other -> record error via `recordJobError()`, continue to next
     - Update progress via `updateJobProgress(job.id, completedCount, totalCount, 50)` after each success
   - After batch, update stageResults with current succeeded/failed/skipped counts

2. `executeAddVideos(job: SyncJobRecord, accessToken: string, batchSize: number): Promise<void>`
   - Query syncVideoOperations WHERE `syncJobId = job.id` AND `status = 'pending'` LIMIT batchSize
   - If none remain, record stageResults for add_videos and call `advanceStage(job.id, 'delete_playlists')`
   - For each operation:
     - Look up the category's `youtubePlaylistId` from categories table
     - If youtubePlaylistId is null, mark operation as 'skipped' with error "Category playlist not created", continue
     - Call `addVideoToPlaylist(accessToken, youtubePlaylistId, op.youtubeVideoId)` from write-operations.ts
     - On success: update syncVideoOperations SET status='completed', completedAt=now
     - On error:
       - 403 quotaExceeded -> pause sync, return
       - 409 conflict/duplicate -> mark as 'completed' (idempotent -- video already in playlist)
       - Other -> update syncVideoOperations SET status='failed', errorMessage=error.message. Record error via `recordJobError()`
     - Update progress: count total completed+failed+skipped vs total operations for this job
   - After batch, update stageResults

3. `executeDeletePlaylists(job: SyncJobRecord, accessToken: string, batchSize: number): Promise<void>`
   - Query playlists WHERE `deletedFromYoutubeAt IS NULL` LIMIT batchSize
   - If none remain, record stageResults for delete_playlists and call `advanceStage(job.id, 'completed')`
   - For each playlist:
     - Call `deleteYouTubePlaylist(accessToken, playlist.youtubeId)` from write-operations.ts
     - On success: update playlists SET `deletedFromYoutubeAt = now`
     - On error:
       - 404 Not Found -> treat as success (already deleted). Update deletedFromYoutubeAt.
       - 403 quotaExceeded -> pause sync, return
       - Other -> record error, continue
     - Update progress
   - After batch, update stageResults

**Error handling pattern for all stages:**
```typescript
try {
  // API call
} catch (error: any) {
  const status = error?.response?.status;
  const reason = error?.response?.data?.error?.errors?.[0]?.reason;

  if (status === 403 && reason === 'quotaExceeded') {
    await pauseSyncJob(job.id, 'quota_exhausted');
    return; // Stop processing immediately
  }

  if (status === 404) {
    // Treat as success for delete operations (idempotent)
    // For other stages, record as error
  }

  // Collect error, continue to next operation
  await recordJobError(job.id, {
    stage: 'current_stage',
    entityType: 'playlist' or 'video',
    entityId: 'youtube_id',
    message: error?.message || 'Unknown error',
    timestamp: new Date().toISOString(),
  });
}
```

**IMPORTANT:** The `executeCreatePlaylists` function must populate the `syncVideoOperations` table when advancing to add_videos. This pre-populates all the video assignments that need to happen, enabling:
- Accurate progress tracking (count pending vs completed)
- Idempotent resume (skip completed operations)
- Failure tracking per video
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `grep -r "executeCreatePlaylists\|executeAddVideos\|executeDeletePlaylists" src/lib/sync/stages.ts` shows all three exports
3. All three functions handle quota exhaustion by calling pauseSyncJob
4. All three functions handle idempotent resume (skip already-completed items)
  </verify>
  <done>Three stage executors process batches of YouTube API operations with idempotent resume, quota-aware pausing, and error collection. create_playlists stores YouTube IDs on categories. add_videos tracks per-video status. delete_playlists treats 404 as success.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. computeSyncPreview queries real data and returns SyncPreview with accurate counts
3. Engine creates jobs, transitions stages, pauses on quota, and resumes from correct stage
4. Stage executors are idempotent (skip completed items on resume)
5. All YouTube API errors are handled: 403 quotaExceeded pauses, 404 on delete is success, others are collected
</verification>

<success_criteria>
- Sync preview accurately computes operation counts and quota costs from actual database data
- Engine state machine transitions: pending -> backup -> create_playlists -> add_videos -> delete_playlists -> completed
- Quota exhaustion pauses sync with clear reason and correct stage for resume
- Each stage executor processes a batch and returns (fire-and-process pattern)
- Idempotent resume: completed operations are skipped on retry
- Errors are collected per stage, not thrown (batch failures pattern from CONTEXT.md)
</success_criteria>

<output>
After completion, create `.planning/phases/08-batch-sync-operations/08-02-SUMMARY.md`
</output>
