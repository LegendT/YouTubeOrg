---
phase: 08-batch-sync-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - src/types/sync.ts
  - src/lib/youtube/write-operations.ts
  - src/lib/auth/config.ts
autonomous: true

must_haves:
  truths:
    - "syncJobs and syncVideoOperations tables exist in database after push"
    - "categories table has youtubePlaylistId column"
    - "playlists table has deletedFromYoutubeAt column"
    - "TypeScript types for sync workflow compile without errors"
    - "YouTube write operation wrappers use existing callYouTubeAPI and trackQuotaUsage"
    - "OAuth scope includes youtube.force-ssl for write access"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "syncJobs table, syncVideoOperations table, youtubePlaylistId column on categories, deletedFromYoutubeAt column on playlists"
      contains: "syncJobs"
    - path: "src/types/sync.ts"
      provides: "SyncStage, SyncJobRecord, SyncPreview, SyncVideoOperationRecord, SyncError, StageResults types"
      min_lines: 50
    - path: "src/lib/youtube/write-operations.ts"
      provides: "createYouTubePlaylist, addVideoToPlaylist, deleteYouTubePlaylist functions"
      exports: ["createYouTubePlaylist", "addVideoToPlaylist", "deleteYouTubePlaylist"]
    - path: "src/lib/auth/config.ts"
      provides: "OAuth scope upgrade to youtube.force-ssl"
      contains: "youtube.force-ssl"
  key_links:
    - from: "src/lib/youtube/write-operations.ts"
      to: "src/lib/rate-limiter.ts"
      via: "callYouTubeAPI import"
      pattern: "import.*callYouTubeAPI.*rate-limiter"
    - from: "src/lib/youtube/write-operations.ts"
      to: "src/lib/youtube/quota.ts"
      via: "trackQuotaUsage import"
      pattern: "import.*trackQuotaUsage.*quota"
---

<objective>
Lay the foundation for Phase 8 sync operations: database schema for sync tracking, TypeScript types, YouTube API write operation wrappers, and OAuth scope upgrade.

Purpose: Everything else in Phase 8 depends on these primitives. The schema stores sync state across multi-day operations. The write wrappers encapsulate YouTube API calls with quota tracking. The OAuth upgrade enables write access.

Output: 4 modified/created files providing the data layer, type definitions, API wrappers, and auth configuration for the sync pipeline.
</objective>

<execution_context>
@/Users/anthonygeorge/.claude/get-shit-done/workflows/execute-plan.md
@/Users/anthonygeorge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-batch-sync-operations/08-RESEARCH.md
@.planning/phases/08-batch-sync-operations/08-CONTEXT.md
@src/lib/db/schema.ts
@src/lib/youtube/client.ts
@src/lib/youtube/quota.ts
@src/lib/rate-limiter.ts
@src/lib/auth/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database schema additions and TypeScript types</name>
  <files>src/lib/db/schema.ts, src/types/sync.ts</files>
  <action>
**In `src/lib/db/schema.ts`**, add the following after the Phase 7 section:

1. Add a new section comment: `// --- Phase 8: Batch Sync Operations ---`

2. Add `youtubePlaylistId` column to the existing `categories` table:
   - `youtubePlaylistId: text('youtube_playlist_id')` -- nullable, stores the YouTube playlist ID after creation during sync

3. Add `deletedFromYoutubeAt` column to the existing `playlists` table:
   - `deletedFromYoutubeAt: timestamp('deleted_from_youtube_at')` -- nullable, tracks when old playlists were deleted for idempotent resume

4. Create `syncJobs` table with columns:
   - `id: serial('id').primaryKey()`
   - `stage: text('stage').notNull().default('pending')` -- SyncStage values: pending, backup, create_playlists, add_videos, delete_playlists, completed, failed, paused
   - `currentStageProgress: integer('current_stage_progress').notNull().default(0)`
   - `currentStageTotal: integer('current_stage_total').notNull().default(0)`
   - `stageResults: jsonb('stage_results').notNull().default('{}')` -- per-stage success/failure/skipped counts
   - `errors: jsonb('errors').notNull().default('[]')` -- collected errors array
   - `quotaUsedThisSync: integer('quota_used_this_sync').notNull().default(0)`
   - `pauseReason: text('pause_reason')` -- 'quota_exhausted' | 'user_paused' | 'errors_collected' | null
   - `previewData: jsonb('preview_data')` -- cached SyncPreview for display during/after sync
   - `startedAt: timestamp('started_at').notNull().defaultNow()`
   - `completedAt: timestamp('completed_at')`
   - `lastResumedAt: timestamp('last_resumed_at')`
   - `backupSnapshotId: integer('backup_snapshot_id').references(() => backupSnapshots.id)` -- link to pre-sync backup

5. Create `syncVideoOperations` table with columns:
   - `id: serial('id').primaryKey()`
   - `syncJobId: integer('sync_job_id').references(() => syncJobs.id).notNull()`
   - `categoryId: integer('category_id').references(() => categories.id).notNull()`
   - `videoId: integer('video_id').references(() => videos.id).notNull()`
   - `youtubeVideoId: text('youtube_video_id').notNull()` -- denormalised for API calls without joins
   - `status: text('status').notNull().default('pending')` -- pending, completed, failed, skipped
   - `errorMessage: text('error_message')`
   - `completedAt: timestamp('completed_at')`

6. Run `npx drizzle-kit push` to apply schema changes.

**Create `src/types/sync.ts`** with the following type definitions:

```typescript
export type SyncStage =
  | 'pending'
  | 'backup'
  | 'create_playlists'
  | 'add_videos'
  | 'delete_playlists'
  | 'completed'
  | 'failed'
  | 'paused';

export type PauseReason = 'quota_exhausted' | 'user_paused' | 'errors_collected';

export interface SyncError {
  stage: string;
  entityType: 'playlist' | 'video';
  entityId: string;
  message: string;
  timestamp: string; // ISO 8601
}

export interface StageResults {
  [stage: string]: {
    succeeded: number;
    failed: number;
    skipped: number;
  };
}

export interface SyncPreview {
  stages: {
    createPlaylists: {
      count: number;
      quotaCost: number;
      items: Array<{ categoryName: string; categoryId: number }>;
    };
    addVideos: {
      count: number;
      quotaCost: number;
      byCategory: Array<{ categoryName: string; categoryId: number; videoCount: number }>;
    };
    deletePlaylists: {
      count: number;
      quotaCost: number;
      items: Array<{ playlistName: string; playlistId: number; youtubeId: string }>;
    };
  };
  totalQuotaCost: number;
  estimatedDays: number;
  dailyQuotaLimit: number;
}

// Represents a syncJobs row as returned from the database
export interface SyncJobRecord {
  id: number;
  stage: SyncStage;
  currentStageProgress: number;
  currentStageTotal: number;
  stageResults: StageResults;
  errors: SyncError[];
  quotaUsedThisSync: number;
  pauseReason: PauseReason | null;
  previewData: SyncPreview | null;
  startedAt: Date;
  completedAt: Date | null;
  lastResumedAt: Date | null;
  backupSnapshotId: number | null;
}

// Represents a syncVideoOperations row
export type SyncVideoStatus = 'pending' | 'completed' | 'failed' | 'skipped';

export interface SyncVideoOperationRecord {
  id: number;
  syncJobId: number;
  categoryId: number;
  videoId: number;
  youtubeVideoId: string;
  status: SyncVideoStatus;
  errorMessage: string | null;
  completedAt: Date | null;
}

// Stage display labels for the UI
export const STAGE_LABELS: Record<SyncStage, string> = {
  pending: 'Ready to sync',
  backup: 'Creating backup',
  create_playlists: 'Creating playlists',
  add_videos: 'Adding videos',
  delete_playlists: 'Deleting old playlists',
  completed: 'Sync complete',
  failed: 'Sync failed',
  paused: 'Sync paused',
};
```
  </action>
  <verify>
1. `npx drizzle-kit push` succeeds without errors
2. `npx tsc --noEmit` passes (types compile)
3. Database has new tables: `SELECT * FROM sync_jobs LIMIT 0;` and `SELECT * FROM sync_video_operations LIMIT 0;` succeed
4. Categories table has youtube_playlist_id column: `SELECT youtube_playlist_id FROM categories LIMIT 0;` succeeds
5. Playlists table has deleted_from_youtube_at column: `SELECT deleted_from_youtube_at FROM playlists LIMIT 0;` succeeds
  </verify>
  <done>syncJobs and syncVideoOperations tables exist in the database. categories has youtubePlaylistId column. playlists has deletedFromYoutubeAt column. All sync types compile without errors.</done>
</task>

<task type="auto">
  <name>Task 2: YouTube write operation wrappers and OAuth scope upgrade</name>
  <files>src/lib/youtube/write-operations.ts, src/lib/auth/config.ts</files>
  <action>
**Create `src/lib/youtube/write-operations.ts`** with three functions:

1. `createYouTubePlaylist(accessToken: string, title: string, description?: string): Promise<string>`
   - Creates a YouTube API client via `createYouTubeClient(accessToken)`
   - Calls `youtube.playlists.insert` with `part: ['snippet', 'status']`, `requestBody: { snippet: { title, description: description || '' }, status: { privacyStatus: 'private' } }`
   - Wraps in `callYouTubeAPI()` with weight `QUOTA_COSTS['playlists.insert']` (50 units)
   - Calls `trackQuotaUsage('playlists.insert', { title })` after successful creation
   - Returns `response.id` (the new YouTube playlist ID)
   - Throws if no ID in response

2. `addVideoToPlaylist(accessToken: string, playlistId: string, videoId: string): Promise<string>`
   - Creates YouTube client
   - Calls `youtube.playlistItems.insert` with `part: ['snippet']`, `requestBody: { snippet: { playlistId, resourceId: { kind: 'youtube#video', videoId } } }`
   - Wraps in `callYouTubeAPI()` with weight 50 units
   - Calls `trackQuotaUsage('playlistItems.insert', { playlistId, videoId })`
   - Returns `response.id` (playlist item ID)

3. `deleteYouTubePlaylist(accessToken: string, playlistId: string): Promise<void>`
   - Creates YouTube client
   - Calls `youtube.playlists.delete({ id: playlistId })`
   - Wraps in `callYouTubeAPI()` with weight 50 units
   - Calls `trackQuotaUsage('playlists.delete', { playlistId })`
   - Returns void

Import from existing modules:
- `createYouTubeClient` from `@/lib/youtube/client`
- `callYouTubeAPI` from `@/lib/rate-limiter`
- `trackQuotaUsage, QUOTA_COSTS` from `@/lib/youtube/quota`

**In `src/lib/auth/config.ts`**, update the OAuth scope:
- Change `scope: "openid email profile https://www.googleapis.com/auth/youtube.readonly"` to `scope: "openid email profile https://www.googleapis.com/auth/youtube.force-ssl"`
- Add a comment explaining: `// youtube.force-ssl grants read AND write access (required for Phase 8 sync operations). User must re-authenticate to grant the new scope.`
  </action>
  <verify>
1. `npx tsc --noEmit` passes (write operations compile, imports resolve)
2. `grep -r "youtube.force-ssl" src/lib/auth/config.ts` returns the updated scope line
3. `grep -r "createYouTubePlaylist\|addVideoToPlaylist\|deleteYouTubePlaylist" src/lib/youtube/write-operations.ts` shows all three exports
  </verify>
  <done>Three YouTube write operation wrappers exist using existing callYouTubeAPI + trackQuotaUsage. OAuth scope upgraded to youtube.force-ssl. User must re-authenticate on next sign-in to grant write access.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. Database has syncJobs and syncVideoOperations tables
3. categories.youtubePlaylistId and playlists.deletedFromYoutubeAt columns exist
4. write-operations.ts exports three functions that compile
5. auth/config.ts contains youtube.force-ssl scope
</verification>

<success_criteria>
- Database schema supports sync job tracking with stage-based state machine
- Per-video operation tracking supports idempotent resume of add_videos stage
- YouTube write operations wrap googleapis with existing rate limiter and quota tracker
- OAuth scope enables write operations (user must re-authenticate)
- All code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-batch-sync-operations/08-01-SUMMARY.md`
</output>
