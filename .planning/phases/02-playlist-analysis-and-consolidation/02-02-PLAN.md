---
phase: 02-playlist-analysis-and-consolidation
plan: 02
type: execute
wave: 3
depends_on: [02-01, 02-05]
files_modified:
  - src/app/actions/analysis.ts
  - src/lib/analysis/consolidation.ts
autonomous: true

must_haves:
  truths:
    - "System can generate consolidation proposals from existing playlists"
    - "User can approve a consolidation proposal"
    - "User can reject a consolidation proposal"
    - "System persists proposals in database with status tracking"
  artifacts:
    - path: "src/app/actions/analysis.ts"
      provides: "Server actions for proposal workflow"
      exports: ["generateConsolidationProposal", "approveProposal", "rejectProposal", "getProposals"]
      min_lines: 80
    - path: "src/lib/analysis/consolidation.ts"
      provides: "Business logic for proposal generation"
      exports: ["createConsolidationProposals", "calculateDeduplicatedCount"]
      min_lines: 60
  key_links:
    - from: "src/app/actions/analysis.ts"
      to: "src/lib/analysis/clustering.ts"
      via: "clusterPlaylists function call"
      pattern: "import.*clusterPlaylists"
    - from: "src/app/actions/analysis.ts"
      to: "src/lib/analysis/validation.ts"
      via: "validateConsolidation function call"
      pattern: "validateConsolidation\\("
    - from: "src/app/actions/analysis.ts"
      to: "src/lib/db/schema.ts"
      via: "Database inserts and updates"
      pattern: "db\\.(insert|update).*consolidationProposals"
    - from: "src/lib/analysis/consolidation.ts"
      to: "src/lib/analysis/duplicates.ts"
      via: "findDuplicateVideos for dedup calculation"
      pattern: "findDuplicateVideos\\("
---

<objective>
Implement server-side business logic for generating consolidation proposals, approving/rejecting them, and persisting proposal state to database.

Purpose: Orchestration layer connecting clustering algorithms to database persistence and UI actions. Implements the complete proposal workflow without UI components.

Output: Server actions ready for Next.js client components to call. Proposal generation produces validated consolidation suggestions stored in database with pending status.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-playlist-analysis-and-consolidation/02-RESEARCH.md
@.planning/phases/02-playlist-analysis-and-consolidation/02-01-PLAN.md
@.planning/phases/02-playlist-analysis-and-consolidation/02-05-SUMMARY.md
@src/lib/analysis/duplicates.ts
@src/lib/analysis/clustering.ts
@src/lib/analysis/similarity.ts
@src/lib/analysis/validation.ts
@src/lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Consolidation Business Logic</name>
  <files>src/lib/analysis/consolidation.ts</files>
  <action>
Create src/lib/analysis/consolidation.ts with proposal generation logic:

1. **createConsolidationProposals(targetCategories = 30)** async function:
   - Call clusterPlaylists(targetCategories) to get clusters
   - For each cluster:
     - Calculate DEDUPLICATED video count using calculateDeduplicatedCount()
     - Build proposal object: { categoryName, playlistIds: cluster.playlists.map(p => p.id), totalVideos: dedupCount }
   - Validate entire proposal set using validateConsolidation()
   - Return { success: boolean, proposals?: ProposalData[], errors?: string[] }
   - ProposalData type: { categoryName: string, playlistIds: number[], totalVideos: number }

2. **calculateDeduplicatedCount(playlistIds: number[])** async function:
   - Query playlist_videos table for all videos in given playlists
   - Count DISTINCT videoIds (this is post-dedup count)
   - SQL: SELECT COUNT(DISTINCT videoId) FROM playlist_videos WHERE playlistId IN (...)
   - Return: number (accurate count after duplicate removal)
   - Use Drizzle ORM with sql template and inArray() for WHERE clause

Import clusterPlaylists from './clustering.ts', validateConsolidation from './validation.ts', db from '@/lib/db', { sql, inArray, eq } from 'drizzle-orm', { playlistVideos } from '@/lib/db/schema'.

IMPORTANT: Plan 02-05 has already updated clustering.ts to use fast-dice-coefficient and group(k). Use the updated clusterPlaylists function which accepts an AlgorithmMode parameter and returns enriched results with confidence data.

Key insight: Research open question #4 - validation must use deduplicated counts, not raw sums. This prevents falsely rejecting proposals that are safe after deduplication.
  </action>
  <verify>
Run TypeScript compilation: `npx tsc --noEmit`

Check exports: `grep "export" src/lib/analysis/consolidation.ts`

Expected: createConsolidationProposals and calculateDeduplicatedCount exported. No type errors.
  </verify>
  <done>
File exists with both async functions. calculateDeduplicatedCount uses COUNT(DISTINCT videoId) query. createConsolidationProposals validates with deduplicated counts. Returns structured success/error responses.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Server Actions for Proposal Workflow</name>
  <files>src/app/actions/analysis.ts</files>
  <action>
Create src/app/actions/analysis.ts with Next.js 15 Server Actions:

1. File header: 'use server' directive at top

2. **generateConsolidationProposal(targetCategories = 30)** async function:
   - Call createConsolidationProposals(targetCategories)
   - If validation fails, return { success: false, errors }
   - For each proposal in successful result:
     - Insert into consolidationProposals table with status: 'pending'
     - await db.insert(consolidationProposals).values({ categoryName, sourcePlaylistIds: playlistIds, totalVideos, status: 'pending' })
   - Also populate duplicateVideos table:
     - Call findDuplicateVideos()
     - For each duplicate, insert: { videoId, playlistIds, occurrenceCount, analyzedAt: new Date() }
   - Call revalidatePath('/analysis')
   - Return { success: true, proposalCount: proposals.length, duplicateCount: duplicates.length }

3. **approveProposal(proposalId: number)** async function:
   - Update consolidationProposals SET status = 'approved', approvedAt = new Date() WHERE id = proposalId
   - Use Drizzle: db.update(consolidationProposals).set({ status: 'approved', approvedAt: new Date() }).where(eq(consolidationProposals.id, proposalId))
   - Call revalidatePath('/analysis')
   - Return { success: true }

4. **rejectProposal(proposalId: number, notes?: string)** async function:
   - Update consolidationProposals SET status = 'rejected', notes = notes WHERE id = proposalId
   - Call revalidatePath('/analysis')
   - Return { success: true }

5. **getProposals()** async function:
   - Query all proposals: db.select().from(consolidationProposals).orderBy(desc(consolidationProposals.totalVideos))
   - For each proposal, fetch playlist details for sourcePlaylistIds:
     - Query playlists WHERE id IN (sourcePlaylistIds)
     - Attach playlist titles to response
   - Return array: Array<{ id, categoryName, playlists: Array<{id, title}>, totalVideos, status, createdAt, approvedAt }>

6. **getDuplicateStats()** async function:
   - Call calculateOverlapStats()
   - Return stats object

Import all analysis functions from @/lib/analysis/*. Import { revalidatePath } from 'next/cache'. Import db and schema from @/lib/db. Use Drizzle ORM patterns throughout.

Follow research PATTERN from Server Action example (line 678-733). These are the orchestration functions that UI will call.
  </action>
  <verify>
Run TypeScript compilation: `npx tsc --noEmit`

Check 'use server': `head -1 src/app/actions/analysis.ts`

Expected: First line is 'use server'. All functions are async and exported. No type errors.

Grep check: `grep -E "export async function (generate|approve|reject|get)" src/app/actions/analysis.ts`

Expected: All 5 server actions present.
  </verify>
  <done>
File exists with 'use server' directive. Five server actions implemented. Database operations use Drizzle ORM. revalidatePath called after mutations. Functions return structured responses. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add TypeScript Types for Proposal Data</name>
  <files>src/types/analysis.ts</files>
  <action>
Create src/types/analysis.ts with shared type definitions:

```typescript
export type ProposalStatus = 'pending' | 'approved' | 'rejected';

export interface PlaylistSummary {
  id: number;
  title: string;
}

export interface ConsolidationProposal {
  id: number;
  categoryName: string;
  playlists: PlaylistSummary[];
  totalVideos: number;
  status: ProposalStatus;
  createdAt: Date;
  approvedAt?: Date;
  notes?: string;
}

export interface DuplicateVideo {
  videoId: number;
  videoYoutubeId: string;
  title: string;
  playlistCount: number;
  playlists: Array<{ playlistId: number; playlistTitle: string }>;
}

export interface OverlapStats {
  totalUniqueVideos: number;
  duplicateVideoCount: number;
  duplicationPercentage: number;
}

export interface ProposalGenerationResult {
  success: boolean;
  proposalCount?: number;
  duplicateCount?: number;
  errors?: string[];
}
```

Export all types. These are shared between server actions and client components.

Update src/app/actions/analysis.ts to import and use these types in return signatures (add : ProposalGenerationResult, : ConsolidationProposal[], etc.).
  </action>
  <verify>
Run TypeScript compilation: `npx tsc --noEmit`

Check exports: `grep "export" src/types/analysis.ts`

Expected: All interfaces and types exported. analysis.ts uses these types. No type errors.
  </verify>
  <done>
src/types/analysis.ts exists with all type definitions exported. Server actions use these types for return values and parameters. TypeScript compilation succeeds with full type safety.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **TypeScript compilation clean:** `npx tsc --noEmit` returns no errors
2. **Server actions file exists:** ls src/app/actions/ shows analysis.ts with 'use server'
3. **Business logic file exists:** ls src/lib/analysis/ shows consolidation.ts
4. **Types file exists:** ls src/types/ shows analysis.ts
5. **Correct exports:** grep "export" on each file shows all expected functions/types
6. **Server actions structure:** grep "async function" src/app/actions/analysis.ts shows 5 functions

Test proposal generation logic (optional dry-run if desired):
```bash
# Create test script test-proposal.ts in project root
echo "import { generateConsolidationProposal } from './src/app/actions/analysis'
generateConsolidationProposal(30).then(console.log)" > test-proposal.ts

# Run with tsx (requires database with playlists)
npx tsx test-proposal.ts
# Clean up
rm test-proposal.ts
```

Expected: Returns { success: true, proposalCount: N } or { success: false, errors: [...] }
</verification>

<success_criteria>
Plan complete when:
- consolidation.ts exists with createConsolidationProposals and calculateDeduplicatedCount
- analysis.ts server actions exist with 5 exported functions
- Types defined in src/types/analysis.ts
- All TypeScript compiles without errors
- Server actions use Drizzle ORM for database operations
- Proposal validation uses deduplicated video counts (not raw sums)
- Ready for UI integration in next plan
</success_criteria>

<output>
After completion, create `.planning/phases/02-playlist-analysis-and-consolidation/02-02-SUMMARY.md` following the template structure.
</output>
