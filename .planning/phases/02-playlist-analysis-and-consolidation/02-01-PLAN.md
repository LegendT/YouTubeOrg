---
phase: 02-playlist-analysis-and-consolidation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - src/lib/analysis/duplicates.ts
  - src/lib/analysis/clustering.ts
  - src/lib/analysis/validation.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "System can identify videos appearing in multiple playlists"
    - "System can group similar playlist titles into clusters"
    - "System validates that no proposed category exceeds 4,500 videos"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "Database tables for consolidation proposals and duplicate tracking"
      contains: "consolidationProposals, duplicateVideos, proposalStatusEnum"
      min_lines: 80
    - path: "src/lib/analysis/duplicates.ts"
      provides: "SQL queries for duplicate video detection"
      exports: ["findDuplicateVideos", "calculateOverlapStats"]
      min_lines: 60
    - path: "src/lib/analysis/clustering.ts"
      provides: "Playlist similarity clustering with Dice coefficient"
      exports: ["clusterPlaylists", "generateCategoryName"]
      min_lines: 100
    - path: "src/lib/analysis/validation.ts"
      provides: "Zod schemas for consolidation validation"
      exports: ["PlaylistConsolidationSchema", "ConsolidationProposalSchema", "validateConsolidation"]
      min_lines: 40
  key_links:
    - from: "src/lib/analysis/duplicates.ts"
      to: "src/lib/db/schema.ts"
      via: "Drizzle ORM imports"
      pattern: "import.*from.*db/schema"
    - from: "src/lib/analysis/clustering.ts"
      to: "string-similarity"
      via: "Dice coefficient calculation"
      pattern: "stringSimilarity\\.compareTwoStrings"
    - from: "src/lib/analysis/clustering.ts"
      to: "ml-hclust"
      via: "AGNES hierarchical clustering"
      pattern: "agnes\\(distanceMatrix"
    - from: "src/lib/analysis/validation.ts"
      to: "zod"
      via: "Schema validation"
      pattern: "z\\.object\\(\\{"
---

<objective>
Implement backend analysis engine for detecting duplicate videos across playlists and clustering similar playlists into proposed categories using string similarity algorithms.

Purpose: Foundational analysis logic that enables consolidation proposals. This plan focuses on the core algorithms and data structures without UI.

Output: Database schema extended with consolidation tables, duplicate detection SQL queries, hierarchical clustering algorithm, and validation schemas ready for server action integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-playlist-analysis-and-consolidation/02-RESEARCH.md
@src/lib/db/schema.ts
@src/lib/db/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Database Schema with Consolidation Tables</name>
  <files>src/lib/db/schema.ts</files>
  <action>
Add three new elements to schema.ts for consolidation workflow:

1. **proposalStatusEnum** - pgEnum with values ['pending', 'approved', 'rejected']

2. **consolidationProposals** table:
   - id: serial primary key
   - categoryName: text, not null
   - sourcePlaylistIds: jsonb typed as number[] (array of playlist IDs to merge), not null
   - totalVideos: integer, not null
   - status: proposalStatusEnum, not null, default 'pending'
   - createdAt: timestamp, not null, defaultNow()
   - approvedAt: timestamp (nullable)
   - notes: text (nullable, for user comments)

3. **duplicateVideos** table:
   - id: serial primary key
   - videoId: integer, references videos.id, not null
   - playlistIds: jsonb typed as number[] (playlists containing this video), not null
   - occurrenceCount: integer, not null
   - analyzedAt: timestamp, not null, defaultNow()

Add these AFTER the existing quotaUsage table definition. Use the same patterns as existing tables (serial() for IDs, timestamp().notNull().defaultNow() for timestamps).

Do NOT run drizzle push yet - that happens in verification after all files are ready.
  </action>
  <verify>
Run: `grep -E "(consolidationProposals|duplicateVideos|proposalStatusEnum)" src/lib/db/schema.ts`

Expected: All three new elements present in file. Verify export statements at bottom include new tables.
  </verify>
  <done>
Schema file contains consolidationProposals table with 8 columns, duplicateVideos table with 5 columns, and proposalStatusEnum with 3 values. File compiles without TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Duplicate Video Detection</name>
  <files>src/lib/analysis/duplicates.ts</files>
  <action>
Create src/lib/analysis/duplicates.ts implementing SQL-based duplicate detection:

1. **findDuplicateVideos()** function:
   - Query playlistVideos table with GROUP BY videoId
   - Use HAVING count(distinct playlistId) > 1 to find duplicates
   - Join with videos table to get title, youtubeId
   - Return array with: videoId, videoYoutubeId, title, playlistCount
   - For each duplicate, fetch the playlists containing it (nested query)
   - Return: { videoId, videoYoutubeId, title, playlistCount, playlists: Array<{playlistId, playlistTitle}> }

2. **calculateOverlapStats()** function:
   - Count total unique videos: SELECT COUNT(DISTINCT videoId) FROM playlist_videos
   - Count duplicate videos: subquery with GROUP BY + HAVING COUNT > 1
   - Calculate duplication percentage
   - Return: { totalUniqueVideos, duplicateVideoCount, duplicationPercentage }

Use Drizzle ORM sql tagged template for aggregations. Import { eq, sql } from 'drizzle-orm'. Follow patterns from research PATTERN 1 exactly.

DO NOT use raw SQL strings. Use Drizzle's query builder and sql template tag for aggregations.
  </action>
  <verify>
Run TypeScript compilation: `npx tsc --noEmit`

Expected: No type errors. File exports both functions with correct return types.

Grep check: `grep -E "(findDuplicateVideos|calculateOverlapStats)" src/lib/analysis/duplicates.ts | grep export`
  </verify>
  <done>
File exists with both exported async functions. TypeScript compiles without errors. Functions use Drizzle ORM patterns with sql tagged template for GROUP BY and HAVING clauses.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement Playlist Clustering Algorithm</name>
  <files>src/lib/analysis/clustering.ts, package.json</files>
  <action>
First install required libraries:
```bash
npm install string-similarity ml-hclust
npm install -D @types/string-similarity
```

Then create src/lib/analysis/clustering.ts implementing hierarchical clustering:

1. **clusterPlaylists(targetCategoryCount = 30)** async function:
   - Fetch all playlists from database with id, title, itemCount
   - Build distance matrix using string-similarity compareTwoStrings for all pairs
   - Distance = 1 - similarity (Dice coefficient)
   - Apply ml-hclust agnes() with method: 'average' (UPGMA linkage)
   - Cut tree to produce target cluster count (implement cutDendrogram helper)
   - For each cluster: generate category name, sum totalVideos, collect playlists
   - Return array: Array<{ categoryName: string, playlists: Array<{id, title}>, totalVideos: number }>
   - Sort by totalVideos descending

2. **generateCategoryName(titles: string[])** function:
   - Extract words from all titles, filter out common words ('playlist', 'videos', 'watch', 'the', 'and')
   - Count word frequency
   - Return most common word, capitalized
   - Fallback to 'Uncategorized' if no suitable word found

3. **cutDendrogram(tree, targetCount)** helper:
   - Placeholder implementation for now (return empty array with TODO comment)
   - Comment: "Tree cutting requires traversal logic to find height producing ~targetCount clusters. Defer to implementation phase or accept resulting cluster count from fixed threshold."

Import stringSimilarity from 'string-similarity' (default import). Import { agnes } from 'ml-hclust'. Use db from @/lib/db for fetching playlists.

Follow research PATTERN 2 structure. This is the core consolidation algorithm.
  </action>
  <verify>
Run TypeScript compilation: `npx tsc --noEmit`

Check exports: `grep -E "export (async )?function" src/lib/analysis/clustering.ts`

Expected: clusterPlaylists and generateCategoryName exported. No type errors. Libraries installed in package.json.
  </verify>
  <done>
File exists with clusterPlaylists and generateCategoryName functions. string-similarity and ml-hclust installed in package.json. TypeScript compiles. Distance matrix build uses Dice coefficient. agnes() called with average linkage.
  </done>
</task>

<task type="auto">
  <name>Task 4: Implement Consolidation Validation</name>
  <files>src/lib/analysis/validation.ts</files>
  <action>
Create src/lib/analysis/validation.ts with Zod validation schemas:

1. Define constants:
   - YOUTUBE_PLAYLIST_LIMIT = 5000
   - SAFETY_MARGIN = 500
   - MAX_VIDEOS_PER_CATEGORY = 4500

2. **PlaylistConsolidationSchema** = z.object({
   - categoryName: z.string().min(1).max(100)
   - playlistIds: z.array(z.number()).min(1)
   - totalVideos: z.number().max(MAX_VIDEOS_PER_CATEGORY, { message: "Category exceeds safe limit..." })
})

3. **ConsolidationProposalSchema** = z.object({
   - categories: z.array(PlaylistConsolidationSchema)
   - totalCategories: z.number().min(25).max(35, { message: "Target is 25-35 categories..." })
})

4. **validateConsolidation(proposal: unknown)** async function:
   - Use ConsolidationProposalSchema.safeParse(proposal)
   - If invalid, return { valid: false, errors: string[] } with formatted error messages
   - Additional check: filter categories with totalVideos > MAX_VIDEOS_PER_CATEGORY
   - Return { valid: false, errors } if any over limit
   - Otherwise return { valid: true }

Import { z } from 'zod'. Follow research PATTERN 3 exactly. Export all schemas and validate function.

This ensures Phase 2 cannot approve dangerous consolidations that would break YouTube's 5,000 limit.
  </action>
  <verify>
Run TypeScript compilation: `npx tsc --noEmit`

Check exports: `grep "export" src/lib/analysis/validation.ts`

Expected: Three schemas and validateConsolidation function exported. MAX_VIDEOS_PER_CATEGORY constant set to 4500.
  </verify>
  <done>
File exists with all exports. Zod schemas validate category limits. validateConsolidation function returns { valid, errors } structure. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 5: Push Schema Changes to Database</name>
  <files>None (database migration)</files>
  <action>
Now that schema.ts is updated with consolidation tables, push changes to PostgreSQL:

1. Ensure PostgreSQL Docker container is running:
   ```bash
   docker ps | grep youtube-org-db || docker start youtube-org-db
   ```

2. Push schema changes:
   ```bash
   npx drizzle-kit push
   ```

3. Verify tables created:
   ```bash
   docker exec youtube-org-db psql -U postgres -d youtube_organizer -c "\dt"
   ```

Expected: consolidation_proposals and duplicate_videos tables in list alongside existing tables (playlists, videos, playlist_videos, cache_metadata, quota_usage).

If push fails with connection errors, check DATABASE_URL in .env.local matches running container.
  </action>
  <verify>
Run SQL query to confirm schema:
```bash
docker exec youtube-org-db psql -U postgres -d youtube_organizer -c "SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' ORDER BY table_name;"
```

Expected output includes: consolidation_proposals, duplicate_videos (plus all 5 existing tables).

Also verify enum: `docker exec youtube-org-db psql -U postgres -d youtube_organizer -c "SELECT typname FROM pg_type WHERE typtype = 'e';"`

Expected: proposal_status enum exists.
  </verify>
  <done>
Database contains 7 total tables (5 original + 2 new). consolidation_proposals has 8 columns. duplicate_videos has 5 columns. proposal_status enum exists with 3 values.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **TypeScript compilation clean:** `npx tsc --noEmit` returns no errors
2. **All files exist:** ls src/lib/analysis/ shows duplicates.ts, clustering.ts, validation.ts
3. **Schema extended:** grep consolidationProposals src/lib/db/schema.ts returns matches
4. **Database updated:** docker exec query shows 7 tables including new ones
5. **Libraries installed:** grep -E "string-similarity|ml-hclust" package.json returns matches
6. **Exports correct:** Each analysis file exports expected functions (check with grep "export")

No UI yet - that's Plan 02. This plan delivers the analysis engine backend.
</verification>

<success_criteria>
Plan complete when:
- Database schema has consolidationProposals and duplicateVideos tables
- Duplicate detection SQL queries exist and compile
- Playlist clustering algorithm implemented with string-similarity + ml-hclust
- Zod validation schemas enforce 4,500 video limit
- All TypeScript compiles without errors
- Libraries installed: string-similarity, ml-hclust
- Ready for server action integration in next plan
</success_criteria>

<output>
After completion, create `.planning/phases/02-playlist-analysis-and-consolidation/02-01-SUMMARY.md` following the template structure.
</output>
