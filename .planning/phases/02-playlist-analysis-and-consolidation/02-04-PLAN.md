---
phase: 02-playlist-analysis-and-consolidation
plan: 04
type: execute
wave: 4
depends_on: [02-03]
files_modified:
  - src/components/analysis/playlist-merger.tsx
  - src/app/actions/analysis.ts
  - src/app/analysis/page.tsx
  - package.json
autonomous: false

must_haves:
  truths:
    - "User can manually adjust consolidation proposal by moving playlists between categories"
    - "User can drag and drop playlists to reassign categories"
    - "System recalculates video counts when playlist is moved"
    - "System re-validates limits after manual adjustment"
  artifacts:
    - path: "src/components/analysis/playlist-merger.tsx"
      provides: "Drag-and-drop interface for manual playlist reassignment"
      exports: ["PlaylistMerger"]
      min_lines: 150
    - path: "src/app/actions/analysis.ts"
      provides: "Server action for updating proposal playlist membership"
      contains: "updateProposalPlaylists"
  key_links:
    - from: "src/components/analysis/playlist-merger.tsx"
      to: "@dnd-kit/core"
      via: "DndContext for drag-drop"
      pattern: "import.*DndContext.*@dnd-kit/core"
    - from: "src/components/analysis/playlist-merger.tsx"
      to: "@dnd-kit/sortable"
      via: "useSortable hook"
      pattern: "useSortable\\("
    - from: "src/components/analysis/playlist-merger.tsx"
      to: "src/app/actions/analysis.ts"
      via: "updateProposalPlaylists server action"
      pattern: "updateProposalPlaylists\\("
---

<objective>
Add manual adjustment capability allowing users to drag-and-drop playlists between proposed categories with automatic video count recalculation and validation.

Purpose: Implements CAT-09 requirement (manually adjust consolidation proposal). Gives users fine-grained control to override ML clustering results.

Output: Interactive drag-and-drop UI enabling playlist reassignment between categories with live video count updates and validation feedback.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-playlist-analysis-and-consolidation/02-RESEARCH.md
@.planning/phases/02-playlist-analysis-and-consolidation/02-03-PLAN.md
@src/app/actions/analysis.ts
@src/components/analysis/proposal-table.tsx
@src/lib/analysis/consolidation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dnd-kit Libraries</name>
  <files>package.json</files>
  <action>
Install @dnd-kit for drag-and-drop functionality:

```bash
npm install @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities
```

These packages provide:
- @dnd-kit/core: Core drag-and-drop primitives (DndContext, sensors, collision detection)
- @dnd-kit/sortable: Sortable list utilities (useSortable, SortableContext)
- @dnd-kit/utilities: Helper functions (CSS transforms, array moves)

Total size: ~10kb core. Zero dependencies. Accessible (keyboard navigation, screen readers). Modern replacement for archived react-beautiful-dnd.

Verify installation: `grep "@dnd-kit" package.json`

Expected: All three packages in dependencies.
  </action>
  <verify>
Check package.json: `grep -E "@dnd-kit/(core|sortable|utilities)" package.json`

Expected: Three @dnd-kit packages listed in dependencies section.
  </verify>
  <done>
@dnd-kit/core, @dnd-kit/sortable, and @dnd-kit/utilities installed in package.json. Dependencies resolved and node_modules updated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Server Action for Proposal Update</name>
  <files>src/app/actions/analysis.ts</files>
  <action>
Add updateProposalPlaylists server action to existing analysis.ts:

```typescript
export async function updateProposalPlaylists(
  proposalId: number,
  newPlaylistIds: number[]
): Promise<{ success: boolean; newTotal?: number; errors?: string[] }> {
  // Calculate deduplicated video count for new playlist set
  const newTotal = await calculateDeduplicatedCount(newPlaylistIds)

  // Validate against 4,500 limit
  if (newTotal > 4500) {
    return {
      success: false,
      errors: [`Category would have ${newTotal} videos, exceeding safe limit of 4,500`]
    }
  }

  // Update proposal in database
  await db
    .update(consolidationProposals)
    .set({
      sourcePlaylistIds: newPlaylistIds,
      totalVideos: newTotal,
      updatedAt: new Date()
    })
    .where(eq(consolidationProposals.id, proposalId))

  revalidatePath('/analysis')

  return { success: true, newTotal }
}
```

Add this after existing server actions. Import calculateDeduplicatedCount from @/lib/analysis/consolidation. This enables real-time validation during drag-drop operations.

Key: Always recalculate deduplicated count (don't sum itemCounts) because moving playlists may introduce or remove duplicates.
  </action>
  <verify>
Run TypeScript compilation: `npx tsc --noEmit`

Check export: `grep "export async function updateProposalPlaylists" src/app/actions/analysis.ts`

Expected: Function exists, uses calculateDeduplicatedCount, validates limit, updates database. No type errors.
  </verify>
  <done>
updateProposalPlaylists server action added to analysis.ts. Calculates deduplicated count, validates 4,500 limit, updates database with new playlist set. Returns success with new total or error. TypeScript compiles.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Drag-and-Drop Playlist Merger Component</name>
  <files>src/components/analysis/playlist-merger.tsx</files>
  <action>
Create src/components/analysis/playlist-merger.tsx implementing manual adjustment UI:

```typescript
'use client'

import { useState, useTransition } from 'react'
import { DndContext, closestCenter, DragEndEvent, PointerSensor, useSensor, useSensors } from '@dnd-kit/core'
import { SortableContext, verticalListSortingStrategy, useSortable } from '@dnd-kit/sortable'
import { CSS } from '@dnd-kit/utilities'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import { GripVertical, AlertTriangle } from 'lucide-react'
import { updateProposalPlaylists } from '@/app/actions/analysis'
import type { ConsolidationProposal } from '@/types/analysis'

interface PlaylistMergerProps {
  proposals: ConsolidationProposal[]
}

export function PlaylistMerger({ proposals }: PlaylistMergerProps) {
  const [localProposals, setLocalProposals] = useState(proposals)
  const [isPending, startTransition] = useTransition()
  const [error, setError] = useState<string | null>(null)

  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8, // Require 8px movement to start drag (prevents accidental drags)
      },
    })
  )

  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event
    if (!over) return

    const activeId = active.id as string // Format: "proposal-{proposalId}-playlist-{playlistId}"
    const overId = over.id as string

    // Parse IDs
    const [, activeProposalId, , activePlaylistId] = activeId.split('-')
    const [, overProposalId] = overId.split('-')

    if (activeProposalId === overProposalId) return // Same category, no change

    // Find source and target proposals
    const sourceProposal = localProposals.find(p => p.id === Number(activeProposalId))
    const targetProposal = localProposals.find(p => p.id === Number(overProposalId))

    if (!sourceProposal || !targetProposal) return

    // Remove playlist from source
    const movedPlaylist = sourceProposal.playlists.find(p => p.id === Number(activePlaylistId))
    if (!movedPlaylist) return

    const newSourcePlaylists = sourceProposal.playlists.filter(p => p.id !== movedPlaylist.id)
    const newTargetPlaylists = [...targetProposal.playlists, movedPlaylist]

    // Update local state optimistically
    setLocalProposals(prev => prev.map(p => {
      if (p.id === sourceProposal.id) return { ...p, playlists: newSourcePlaylists }
      if (p.id === targetProposal.id) return { ...p, playlists: newTargetPlaylists }
      return p
    }))

    // Persist to database with validation
    startTransition(async () => {
      const sourceResult = await updateProposalPlaylists(
        sourceProposal.id,
        newSourcePlaylists.map(p => p.id)
      )

      const targetResult = await updateProposalPlaylists(
        targetProposal.id,
        newTargetPlaylists.map(p => p.id)
      )

      if (!sourceResult.success || !targetResult.success) {
        setError(sourceResult.errors?.[0] || targetResult.errors?.[0] || 'Update failed')
        // Revert optimistic update
        setLocalProposals(proposals)
      } else {
        setError(null)
        // Update with server-calculated totals
        setLocalProposals(prev => prev.map(p => {
          if (p.id === sourceProposal.id && sourceResult.newTotal) {
            return { ...p, totalVideos: sourceResult.newTotal }
          }
          if (p.id === targetProposal.id && targetResult.newTotal) {
            return { ...p, totalVideos: targetResult.newTotal }
          }
          return p
        }))
      }
    })
  }

  return (
    <div className="space-y-4">
      {error && (
        <div className="bg-destructive/10 text-destructive p-4 rounded-md flex items-center gap-2">
          <AlertTriangle className="w-5 h-5" />
          <span>{error}</span>
        </div>
      )}

      <DndContext
        sensors={sensors}
        collisionDetection={closestCenter}
        onDragEnd={handleDragEnd}
      >
        <div className="grid gap-4">
          {localProposals
            .filter(p => p.status === 'pending')
            .map(proposal => (
              <ProposalCategory
                key={proposal.id}
                proposal={proposal}
                isPending={isPending}
              />
            ))}
        </div>
      </DndContext>
    </div>
  )
}

interface ProposalCategoryProps {
  proposal: ConsolidationProposal
  isPending: boolean
}

function ProposalCategory({ proposal, isPending }: ProposalCategoryProps) {
  const isOverLimit = proposal.totalVideos > 4500
  const isNearLimit = proposal.totalVideos > 4000 && proposal.totalVideos <= 4500

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center justify-between">
          <span>{proposal.categoryName}</span>
          <div className="flex items-center gap-2">
            <span className="text-sm font-normal text-muted-foreground">
              {proposal.totalVideos.toLocaleString()} videos
            </span>
            {isOverLimit && (
              <Badge variant="destructive">
                <AlertTriangle className="w-3 h-3 mr-1" />
                Over Limit
              </Badge>
            )}
            {isNearLimit && <Badge variant="secondary">Near Limit</Badge>}
          </div>
        </CardTitle>
      </CardHeader>
      <CardContent>
        <SortableContext
          items={proposal.playlists.map(p => `proposal-${proposal.id}-playlist-${p.id}`)}
          strategy={verticalListSortingStrategy}
        >
          <div className="space-y-2">
            {proposal.playlists.map(playlist => (
              <DraggablePlaylist
                key={playlist.id}
                proposalId={proposal.id}
                playlist={playlist}
                isPending={isPending}
              />
            ))}
          </div>
        </SortableContext>
      </CardContent>
    </Card>
  )
}

interface DraggablePlaylistProps {
  proposalId: number
  playlist: { id: number; title: string }
  isPending: boolean
}

function DraggablePlaylist({ proposalId, playlist, isPending }: DraggablePlaylistProps) {
  const id = `proposal-${proposalId}-playlist-${playlist.id}`
  const { attributes, listeners, setNodeRef, transform, transition, isDragging } = useSortable({ id })

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
  }

  return (
    <div
      ref={setNodeRef}
      style={style}
      className="flex items-center gap-2 p-2 bg-muted rounded-md cursor-move hover:bg-muted/80"
      {...attributes}
      {...listeners}
    >
      <GripVertical className="w-4 h-4 text-muted-foreground" />
      <span className="text-sm">{playlist.title}</span>
      {isPending && <span className="ml-auto text-xs text-muted-foreground">Updating...</span>}
    </div>
  )
}
```

Implements drag-and-drop between categories. Optimistic UI updates. Server validation. Error handling. Follows research PATTERN 4 (line 315-474) with dnd-kit integration.

Key features:
- Drag playlists between proposal cards
- Live video count recalculation
- Validation feedback (error banner if move exceeds limit)
- Visual feedback (opacity during drag, grip handle)
- Only shows pending proposals (approved/rejected not editable)
  </action>
  <verify>
Run TypeScript compilation: `npx tsc --noEmit`

Check exports: `grep "export function PlaylistMerger" src/components/analysis/playlist-merger.tsx`

Expected: Component exported, uses DndContext, SortableContext, useSortable. No type errors.

Grep dnd-kit usage: `grep -E "(DndContext|useSortable)" src/components/analysis/playlist-merger.tsx`

Expected: Both hooks used.
  </verify>
  <done>
PlaylistMerger component exists as client component. Implements drag-and-drop with @dnd-kit. Optimistic UI updates. Calls updateProposalPlaylists server action. Error handling with validation feedback. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 4: Integrate Playlist Merger into Analysis Page</name>
  <files>src/app/analysis/page.tsx</files>
  <action>
Update src/app/analysis/page.tsx to include PlaylistMerger component:

1. Add import: `import { PlaylistMerger } from '@/components/analysis/playlist-merger'`

2. Add new section after ConsolidationProposalTable:

```typescript
{proposals.filter(p => p.status === 'pending').length > 0 && (
  <div className="space-y-4">
    <div>
      <h2 className="text-2xl font-semibold">Manual Adjustments</h2>
      <p className="text-sm text-muted-foreground">
        Drag playlists between categories to fine-tune consolidation. Video counts update automatically.
      </p>
    </div>
    <PlaylistMerger proposals={proposals} />
  </div>
)}
```

Place this section BELOW the ConsolidationProposalTable but ABOVE the closing container div. Shows manual adjustment UI only when pending proposals exist. Provides clear explanation of drag-and-drop functionality.

Keep existing table for approve/reject workflow. PlaylistMerger complements table (adjust first, then approve).
  </action>
  <verify>
Run TypeScript compilation: `npx tsc --noEmit`

Check import: `grep "import.*PlaylistMerger" src/app/analysis/page.tsx`

Expected: PlaylistMerger imported and used in JSX. No type errors.

Verify structure: File should have sections in order:
1. Header and Generate button
2. DuplicateReport
3. ConsolidationProposalTable
4. PlaylistMerger (new)
  </verify>
  <done>
Analysis page updated with PlaylistMerger section. Import added. Component conditionally rendered when pending proposals exist. Clear instructions provided. TypeScript compiles. Page structure maintained.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Drag-and-drop manual adjustment interface for consolidation proposals with live video count updates and validation.

Built features:
- PlaylistMerger component with @dnd-kit drag-and-drop
- Draggable playlist items between category cards
- Automatic video count recalculation after moves
- Validation preventing moves that exceed 4,500 limit
- Error feedback for invalid moves
- Optimistic UI updates with server-side validation
  </what-built>
  <how-to-verify>
**Prerequisites:** Must have pending consolidation proposals (run Plan 02-03 first and generate proposals).

1. Start dev server: `npm run dev`

2. Visit http://localhost:3000/analysis

3. Scroll to "Manual Adjustments" section (below approval table)

4. Test drag-and-drop:
   - Hover over a playlist item in a category card
   - Click and drag the playlist (grip icon visible)
   - Drag to different category card
   - Drop playlist
   - Verify "Updating..." appears briefly
   - Verify video count updates in both source and target categories

5. Test validation:
   - Try dragging multiple playlists to create a category with >4,500 videos
   - Verify error banner appears: "Category would have X videos, exceeding safe limit..."
   - Verify move is reverted (playlist returns to source)

6. Test multiple moves:
   - Drag playlist from Category A to Category B
   - Then drag different playlist from Category C to Category B
   - Verify counts update correctly after each move
   - Verify no stale state (counts always reflect server values)

7. Visual checks:
   - Grip icon (⋮⋮) visible on hover
   - Dragging playlist becomes semi-transparent (opacity: 0.5)
   - Cards have clear visual separation
   - Video counts displayed prominently with locale formatting
   - Warning badges show for categories near/over limit

8. Accessibility check:
   - Tab through interface
   - Verify keyboard navigation works (Space/Enter to pick up, arrow keys to move, Space/Enter to drop)

9. After adjustments:
   - Return to approval table (scroll up)
   - Verify adjusted proposals show updated playlist membership
   - Click "Approve" on adjusted proposal
   - Verify approval works with new playlist set

10. Console checks:
    - Open browser DevTools console
    - Verify no React errors or warnings
    - Check Network tab: updateProposalPlaylists POST requests on each drop
    - Verify no TypeScript errors in terminal

**Expected behavior:** Smooth drag-and-drop with immediate visual feedback, server validation preventing invalid moves, accurate video count recalculation.
  </how-to-verify>
  <resume-signal>
Type "approved" if drag-and-drop works correctly with validation, or describe issues (drag not working, counts incorrect, validation missing, errors in console).
  </resume-signal>
</task>

</tasks>

<verification>
After completing all tasks:

1. **dnd-kit installed:** grep "@dnd-kit" package.json shows 3 packages
2. **Server action added:** updateProposalPlaylists exists in analysis.ts
3. **Component created:** PlaylistMerger.tsx exists in src/components/analysis/
4. **Page updated:** analysis/page.tsx imports and uses PlaylistMerger
5. **TypeScript compilation clean:** npx tsc --noEmit returns no errors
6. **Human verification passed:** User confirms drag-and-drop works with validation

Manual verification required because drag-and-drop interaction cannot be easily automated without E2E test framework.
</verification>

<success_criteria>
Plan complete when:
- @dnd-kit libraries installed and integrated
- PlaylistMerger component implements drag-and-drop between categories
- updateProposalPlaylists server action validates and persists changes
- Video counts recalculate automatically after moves
- Validation prevents moves exceeding 4,500 video limit
- Error feedback displayed when validation fails
- User verification confirms drag-and-drop functionality
- Phase 2 requirements (CAT-05 through CAT-09, SAFE-04) fully implemented
</success_criteria>

<output>
After completion, create `.planning/phases/02-playlist-analysis-and-consolidation/02-04-SUMMARY.md` following the template structure.
</output>
