---
phase: 01-foundation-and-api-integration
plan: 04
type: execute
wave: 3
depends_on: [01-01, 01-02, 01-03]
files_modified:
  - src/lib/youtube/playlists.ts
  - src/lib/youtube/videos.ts
  - src/app/actions/sync-playlists.ts
autonomous: true

must_haves:
  truths:
    - "System can fetch all user playlists from YouTube with pagination"
    - "System can fetch playlist items (videos) with resume capability"
    - "Fetched data is stored in PostgreSQL with ETag metadata"
    - "Sync operations track progress in database for resumability"
  artifacts:
    - path: "src/lib/youtube/playlists.ts"
      provides: "Playlist fetching with ETag caching and pagination"
      exports: ["fetchAllPlaylists", "syncPlaylistsToDatabase"]
      min_lines: 80
    - path: "src/lib/youtube/videos.ts"
      provides: "Video fetching for playlist items with resume logic"
      exports: ["fetchPlaylistItems", "fetchVideoBatch"]
      min_lines: 100
    - path: "src/app/actions/sync-playlists.ts"
      provides: "Server Action to trigger initial sync"
      exports: ["syncAllData"]
  key_links:
    - from: "src/lib/youtube/playlists.ts"
      to: "src/lib/youtube/client.ts (fetchWithETagCache)"
      via: "Fetch playlists with caching"
      pattern: "fetchWithETagCache.*playlists"
    - from: "src/lib/youtube/videos.ts"
      to: "src/lib/db (playlistVideos, syncState tables)"
      via: "Store video relationships and sync progress"
      pattern: "db.insert.*playlistVideos|syncState"
    - from: "src/app/actions/sync-playlists.ts"
      to: "src/lib/auth/session.ts"
      via: "Get access token from session"
      pattern: "getServerSession.*access_token"
---

<objective>
Implement data synchronization logic to fetch all YouTube playlists and videos, store in PostgreSQL with ETag metadata, and support resume capability for quota-aware partial syncs.

Purpose: Populates local database with user's YouTube data for offline browsing. Implements pagination with resume so initial 4,000-video sync can span multiple days if quota is exhausted.

Output: Server Actions and library functions that fetch, cache, and persist YouTube data with full error recovery.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-and-api-integration/01-RESEARCH.md
@.planning/phases/01-foundation-and-api-integration/01-02-SUMMARY.md
@.planning/phases/01-foundation-and-api-integration/01-03-SUMMARY.md

**Key patterns from research:**
- Code Example: Fetching All Playlists with Pagination and ETag Caching
- Code Example: Fetching Playlist Items with Resume Capability
- Pitfall 4: Pagination Without Quota Awareness
- Critical: Must store nextPageToken in database for resume after quota exhaustion

**Database schema available:**
- `playlists` table with etag, lastFetched
- `videos` table with etag, lastFetched
- `playlistVideos` join table with position
- `syncState` table for tracking pagination progress (needs to be added to schema in this plan)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add syncState Table to Schema</name>
  <files>
    src/lib/db/schema.ts
  </files>
  <action>
Add `syncState` table to existing schema in `src/lib/db/schema.ts`:

```typescript
export const syncState = pgTable('sync_state', {
  id: serial('id').primaryKey(),
  playlistYoutubeId: text('playlist_youtube_id').notNull().unique(),
  nextPageToken: text('next_page_token'),
  itemsFetched: integer('items_fetched').default(0),
  lastSyncAt: timestamp('last_sync_at').notNull().defaultNow(),
})
```

This table tracks pagination progress for resume capability (from research code example).

After adding to schema, push to database:
```bash
npx drizzle-kit push
```

Verify in Drizzle Studio that `sync_state` table now exists.
  </action>
  <verify>
Check table is exported:
```bash
grep "export const syncState" src/lib/db/schema.ts
```

Verify columns exist:
```bash
grep "nextPageToken\|itemsFetched" src/lib/db/schema.ts
```

Confirm database updated:
```bash
npx drizzle-kit studio
# Check sync_state table exists in GUI
```
  </verify>
  <done>
syncState table exists in schema and database with columns for tracking pagination (nextPageToken, itemsFetched). Ready for resume logic implementation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Playlist Fetching with Pagination</name>
  <files>
    src/lib/youtube/playlists.ts
  </files>
  <action>
Create `src/lib/youtube/playlists.ts` implementing research code example "Fetching All Playlists with Pagination and ETag Caching".

Import dependencies:
```typescript
import { google, youtube_v3 } from 'googleapis'
import { callYouTubeAPI } from '@/lib/rate-limiter'
import { fetchWithETagCache } from '@/lib/youtube/client'
import { trackQuotaUsage } from '@/lib/youtube/quota'
import { db } from '@/lib/db'
import { playlists } from '@/lib/db/schema'
```

Implement `fetchAllPlaylists` function:
- Accepts `accessToken: string` parameter
- Loops with `pageToken` until no more pages
- For each page: Call `fetchWithETagCache` with resourceType='playlists', params={ part: ['snippet', 'contentDetails'], mine: true, maxResults: 50, pageToken }
- Wrap in `callYouTubeAPI` with quotaCost=1
- Accumulate all playlist items in array
- Return `youtube_v3.Schema$Playlist[]`

Implement `syncPlaylistsToDatabase` function:
- Calls `fetchAllPlaylists` to get all playlists
- For each playlist: INSERT or UPDATE into `playlists` table
  - youtubeId: playlist.id
  - title: playlist.snippet.title
  - description: playlist.snippet.description
  - thumbnailUrl: playlist.snippet.thumbnails.default.url
  - itemCount: playlist.contentDetails.itemCount
  - etag: playlist.etag
  - lastFetched: new Date()
- Use `onConflictDoUpdate` with target=playlists.youtubeId
- Call `trackQuotaUsage('playlists.list', { count: playlists.length })`
- Return count of playlists synced

**Important:** Handle 403 quotaExceeded errors gracefully - catch and re-throw with context about partial progress.
  </action>
  <verify>
Check exports:
```bash
grep "export.*fetchAllPlaylists\|export.*syncPlaylistsToDatabase" src/lib/youtube/playlists.ts
```

Verify pagination loop:
```bash
grep "pageToken\|nextPageToken" src/lib/youtube/playlists.ts
```

Confirm database operations:
```bash
grep "db.insert.*playlists\|onConflictDoUpdate" src/lib/youtube/playlists.ts
```

Check quota tracking:
```bash
grep "trackQuotaUsage.*playlists.list" src/lib/youtube/playlists.ts
```
  </verify>
  <done>
Playlist fetching functions exist with pagination support. Data is stored in database with upsert logic. Quota usage is tracked. ETag caching is utilized for efficient re-syncs.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement Video Fetching with Resume Capability</name>
  <files>
    src/lib/youtube/videos.ts
  </files>
  <action>
Create `src/lib/youtube/videos.ts` implementing research code example "Fetching Playlist Items with Resume Capability".

Import dependencies:
```typescript
import { google, youtube_v3 } from 'googleapis'
import { callYouTubeAPI } from '@/lib/rate-limiter'
import { fetchWithETagCache } from '@/lib/youtube/client'
import { trackQuotaUsage } from '@/lib/youtube/quota'
import { db } from '@/lib/db'
import { videos, playlistVideos, syncState } from '@/lib/db/schema'
import { eq } from 'drizzle-orm'
```

Implement `fetchPlaylistItems` function:
- Accepts `accessToken: string` and `playlistYoutubeId: string`
- **Resume logic:** Query syncState table for existing progress, get nextPageToken and itemsFetched
- Loop with pagination starting from existing pageToken (if resume)
- For each page:
  - Call `fetchWithETagCache` with resourceType='playlistItems'
  - Extract video IDs from items
  - Call `fetchVideoBatch` to get full video details (separate function)
  - Insert into `playlistVideos` join table with position
  - Update syncState with current progress (nextPageToken, itemsFetched)
  - Log progress: "Fetched X items from playlist Y"
- On completion: Delete syncState entry (sync complete)
- On quotaExceeded error: Log progress and throw (syncState persists for resume)
- Call `trackQuotaUsage('playlistItems.list', ...)`

Implement `fetchVideoBatch` function:
- Accepts `accessToken: string` and `videoIds: string[]`
- Batch video IDs in groups of 50 (YouTube API maxResults)
- Call `fetchWithETagCache` with resourceType='videos', params={ part: ['snippet', 'contentDetails'], id: videoIds.join(',') }
- Insert/update videos in `videos` table
- Return video data

**Error handling:** Catch quotaExceeded specifically, log where sync stopped, preserve syncState for resume.
  </action>
  <verify>
Check exports:
```bash
grep "export.*fetchPlaylistItems\|export.*fetchVideoBatch" src/lib/youtube/videos.ts
```

Verify resume logic:
```bash
grep "syncState.*nextPageToken" src/lib/youtube/videos.ts
```

Confirm batch processing:
```bash
grep "videoIds.*join\|chunk.*50" src/lib/youtube/videos.ts
```

Check error handling:
```bash
grep "quotaExceeded\|403" src/lib/youtube/videos.ts
```
  </verify>
  <done>
Video fetching functions exist with resume capability. Sync progress is stored in database. Batch video fetching optimizes quota usage. Quota exhaustion errors preserve progress for later resume.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create Server Action for Initial Sync</name>
  <files>
    src/app/actions/sync-playlists.ts
  </files>
  <action>
Create `src/app/actions/sync-playlists.ts` to provide a Server Action for triggering data sync from UI.

Add 'use server' directive at top of file.

Import dependencies:
```typescript
import { getServerSession } from '@/lib/auth/session'
import { syncPlaylistsToDatabase } from '@/lib/youtube/playlists'
import { fetchPlaylistItems } from '@/lib/youtube/videos'
import { db } from '@/lib/db'
import { playlists } from '@/lib/db/schema'
```

Implement `syncAllData` Server Action:
```typescript
export async function syncAllData() {
  // Get authenticated session
  const session = await getServerSession()
  if (!session?.access_token) {
    throw new Error('Not authenticated')
  }

  try {
    // Step 1: Sync playlists
    const playlistCount = await syncPlaylistsToDatabase(session.access_token)
    console.log(`Synced ${playlistCount} playlists`)

    // Step 2: Get all playlists from database
    const allPlaylists = await db.select().from(playlists)

    // Step 3: Sync videos for each playlist (with resume support)
    let syncedVideos = 0
    for (const playlist of allPlaylists) {
      await fetchPlaylistItems(session.access_token, playlist.youtubeId)
      syncedVideos++
      console.log(`Synced ${syncedVideos}/${allPlaylists.length} playlists`)
    }

    return { success: true, playlistCount, videoSyncCount: syncedVideos }
  } catch (error: any) {
    if (error.code === 403 && error.message.includes('quotaExceeded')) {
      return {
        success: false,
        error: 'Quota exceeded. Sync will resume tomorrow automatically.',
        partialSuccess: true
      }
    }
    throw error
  }
}
```

This Server Action will be called from dashboard UI (Plan 05) to trigger initial data sync.

**Note:** This is a long-running operation that may hit quota limits. The resume capability in fetchPlaylistItems ensures progress isn't lost.
  </action>
  <verify>
Check 'use server' directive:
```bash
head -1 src/app/actions/sync-playlists.ts | grep "use server"
```

Verify exports:
```bash
grep "export.*syncAllData" src/app/actions/sync-playlists.ts
```

Confirm session check:
```bash
grep "getServerSession\|access_token" src/app/actions/sync-playlists.ts
```

Check quota error handling:
```bash
grep "quotaExceeded\|403" src/app/actions/sync-playlists.ts
```
  </verify>
  <done>
Server Action exists to trigger full data sync (playlists + videos). Session authentication is checked. Quota exhaustion is handled gracefully with partial success response. Ready for UI integration.
  </done>
</task>

</tasks>

<verification>
**Code structure check:**
```bash
# Verify all exports
grep -h "export" src/lib/youtube/playlists.ts src/lib/youtube/videos.ts src/app/actions/sync-playlists.ts

# Check syncState schema exists
grep "syncState" src/lib/db/schema.ts

# Verify pagination logic
grep -n "pageToken" src/lib/youtube/playlists.ts src/lib/youtube/videos.ts

# Confirm database operations
grep "onConflictDoUpdate\|onConflictDoNothing" src/lib/youtube/playlists.ts src/lib/youtube/videos.ts
```

**Logic validation:**
- Playlists fetching loops until no nextPageToken
- Videos fetching checks syncState for resume
- Server Action calls both playlist and video sync
- Quota errors are caught and reported with partial success

**No runtime test yet:** Will be tested in Plan 05 when UI triggers sync.
</verification>

<success_criteria>
- syncState table exists in database schema for tracking pagination
- fetchAllPlaylists function paginates through all user playlists with ETag caching
- syncPlaylistsToDatabase stores playlists in PostgreSQL with upsert logic
- fetchPlaylistItems implements resume capability using syncState table
- fetchVideoBatch optimizes quota by fetching 50 videos per API call
- syncAllData Server Action orchestrates full sync with authentication check
- Quota exhaustion errors are handled gracefully with partial success indicators
- All TypeScript compilation passes (npm run build)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-api-integration/01-04-SUMMARY.md` using the summary template.
</output>
