---
phase: 01-foundation-and-api-integration
plan: 03
type: execute
wave: 2
depends_on: [01-01]
files_modified:
  - src/lib/rate-limiter.ts
  - src/lib/youtube/client.ts
  - src/lib/youtube/quota.ts
autonomous: true

must_haves:
  truths:
    - "YouTube API calls are rate-limited through Bottleneck"
    - "Quota consumption is tracked per operation"
    - "ETag caching layer wraps all list operations"
    - "304 Not Modified responses return cached data"
  artifacts:
    - path: "src/lib/rate-limiter.ts"
      provides: "Bottleneck singleton with quota reservoir"
      exports: ["youtubeRateLimiter", "callYouTubeAPI"]
      min_lines: 40
    - path: "src/lib/youtube/client.ts"
      provides: "YouTube API client with ETag caching"
      exports: ["fetchWithETagCache", "createYouTubeClient"]
      min_lines: 60
    - path: "src/lib/youtube/quota.ts"
      provides: "Quota tracking and estimation utilities"
      exports: ["trackQuotaUsage", "getRemainingQuota", "QUOTA_COSTS"]
  key_links:
    - from: "src/lib/youtube/client.ts"
      to: "src/lib/db (cacheMetadata table)"
      via: "ETag storage and retrieval"
      pattern: "db.*cacheMetadata"
    - from: "src/lib/youtube/playlists.ts, videos.ts (Plan 04)"
      to: "src/lib/youtube/quota.ts (trackQuotaUsage)"
      via: "Database quota tracking after successful operations"
      pattern: "trackQuotaUsage.*playlists\\.list|playlistItems\\.list"
---

<objective>
Implement YouTube API client wrapper with ETag-based caching, rate limiting via Bottleneck, and quota tracking to ensure 10,000 daily unit limit is respected.

Purpose: Core infrastructure for all YouTube API operations. Prevents quota exhaustion through aggressive caching and provides real-time quota monitoring.

Output: Reusable YouTube API client that automatically handles caching, rate limiting, retries, and quota tracking.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-and-api-integration/01-RESEARCH.md
@.planning/phases/01-foundation-and-api-integration/01-01-SUMMARY.md

**Key patterns from research:**
- Pattern 2: YouTube API Client with ETag Caching
- Pattern 3: Rate Limiting with Quota Tracking (Bottleneck Reservoir)
- Critical insight: 304 responses cost 0 quota units (must implement from day 1)
- Pitfall 2: Quota Depletion from Unnecessary Re-fetches

**Note:** This plan is independent of Plan 02 (OAuth) - doesn't actually call YouTube API yet, just sets up the infrastructure. Plan 04 will wire them together.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Rate Limiter with Quota Reservoir</name>
  <files>
    src/lib/rate-limiter.ts
  </files>
  <action>
Create `src/lib/rate-limiter.ts` implementing research Pattern 3 (Rate Limiting with Quota Tracking).

Import Bottleneck:
```typescript
import Bottleneck from 'bottleneck'
```

Create singleton rate limiter:
```typescript
export const youtubeRateLimiter = new Bottleneck({
  reservoir: 10000,                    // Daily quota limit
  reservoirRefreshAmount: 10000,       // Reset to 10k at midnight
  reservoirRefreshInterval: 24 * 60 * 60 * 1000, // 24 hours
  maxConcurrent: 5,                    // Max 5 concurrent requests
  minTime: 200,                        // 200ms between requests
})
```

Add event listeners:
- `depleted`: Log when quota exhausted
- `failed`: Implement retry logic with exponential backoff for 429 errors, no retry for 403 quotaExceeded

Create wrapper function:
```typescript
export async function callYouTubeAPI<T>(
  apiCall: () => Promise<T>,
  quotaCost: number = 1,
  operationType?: string
): Promise<T> {
  return youtubeRateLimiter.schedule({ weight: quotaCost }, async () => {
    const result = await apiCall()
    const remaining = await youtubeRateLimiter.currentReservoir()
    console.log(`Quota remaining: ${remaining} / 10,000 units`)
    return result
  })
}
```

**Note:** The wrapper consumes quota via Bottleneck's reservoir. Actual quota tracking to database via `trackQuotaUsage` is called by the specific operation functions (in playlists.ts, videos.ts) after successful API calls, not in this wrapper.

This wrapper automatically prevents exceeding limits via Bottleneck reservoir.
  </action>
  <verify>
Check exports exist:
```bash
grep "export.*youtubeRateLimiter\|export.*callYouTubeAPI" src/lib/rate-limiter.ts
```

Verify reservoir configuration:
```bash
grep "reservoir.*10000" src/lib/rate-limiter.ts
```

Confirm event handlers exist:
```bash
grep -E "depleted|failed" src/lib/rate-limiter.ts
```
  </verify>
  <done>
Rate limiter singleton exists with quota reservoir set to 10,000 units. Wrapper function provides consistent API for quota-aware calls. Event handlers log depletion and retry on rate limit errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create YouTube API Client with ETag Caching</name>
  <files>
    src/lib/youtube/client.ts
  </files>
  <action>
Create `src/lib/youtube/client.ts` implementing research Pattern 2 (YouTube API Client with ETag Caching).

Import dependencies:
```typescript
import { google } from 'googleapis'
import { db } from '@/lib/db'
import { cacheMetadata } from '@/lib/db/schema'
import { eq } from 'drizzle-orm'
```

Create helper to initialize YouTube client:
```typescript
export function createYouTubeClient(accessToken: string) {
  const oauth2Client = new google.auth.OAuth2()
  oauth2Client.setCredentials({ access_token: accessToken })
  return google.youtube({ version: 'v3', auth: oauth2Client })
}
```

Implement `fetchWithETagCache` function:
1. Generate cache key from resourceType + params: `${resourceType}:${JSON.stringify(params)}`
2. Query database for existing ETag: `SELECT etag, data FROM cache_metadata WHERE cache_key = ?`
3. If ETag exists, add to request headers: `headers['If-None-Match'] = cachedEtag`
4. Call YouTube API with googleapis client
5. On 200 response: Store new ETag and data in database (INSERT or UPDATE)
6. On 304 response: Return cached data from database (costs 0 quota units!)
7. On other errors: Throw error for rate limiter to handle

**Error handling:** Wrap in try/catch, check `error.code === 304` specifically (googleapis throws 304 as error, not success).

**Database operations:** Use Drizzle's `onConflictDoUpdate` to upsert cache entries:
```typescript
await db.insert(cacheMetadata).values({...}).onConflictDoUpdate({
  target: cacheMetadata.cacheKey,
  set: { etag: newEtag, data: newData, timestamp: new Date() }
})
```
  </action>
  <verify>
Check exports:
```bash
grep "export.*fetchWithETagCache\|export.*createYouTubeClient" src/lib/youtube/client.ts
```

Verify ETag header is set:
```bash
grep "If-None-Match" src/lib/youtube/client.ts
```

Confirm 304 handling:
```bash
grep -A 3 "304" src/lib/youtube/client.ts | grep "cached"
```

Check database import:
```bash
grep "import.*db.*cacheMetadata" src/lib/youtube/client.ts
```
  </verify>
  <done>
YouTube API client wrapper exists with ETag caching logic. 304 responses return cached data without consuming quota. Cache entries are stored in PostgreSQL with upsert logic. Client helper creates authenticated googleapis instances.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Quota Tracking Utilities</name>
  <files>
    src/lib/youtube/quota.ts
  </files>
  <action>
Create `src/lib/youtube/quota.ts` to centralize quota cost definitions and tracking.

Define quota costs for YouTube API operations (from research - YouTube API Official Docs):
```typescript
export const QUOTA_COSTS = {
  'playlists.list': 1,
  'playlistItems.list': 1,
  'videos.list': 1,
  'playlists.insert': 50,
  'playlists.update': 50,
  'playlists.delete': 50,
  'playlistItems.insert': 50,
  'playlistItems.delete': 50,
} as const
```

Create `trackQuotaUsage` function:
```typescript
export async function trackQuotaUsage(
  operation: keyof typeof QUOTA_COSTS,
  details?: any
): Promise<void> {
  const cost = QUOTA_COSTS[operation]
  await db.insert(quotaUsage).values({
    date: new Date(),
    unitsUsed: cost,
    operation,
    details: details ? JSON.stringify(details) : null,
  })
}
```

Create `getRemainingQuota` function:
```typescript
export async function getRemainingQuota(): Promise<number> {
  const today = new Date()
  today.setHours(0, 0, 0, 0)

  const result = await db
    .select({ total: sql<number>`sum(${quotaUsage.unitsUsed})` })
    .from(quotaUsage)
    .where(sql`${quotaUsage.date} >= ${today}`)

  const used = result[0]?.total || 0
  return 10000 - used
}
```

These utilities provide quota monitoring for the dashboard UI (Plan 05).

**Import note:** Need `sql` from 'drizzle-orm' for aggregation query.
  </action>
  <verify>
Check exports:
```bash
grep "export.*QUOTA_COSTS\|export.*trackQuotaUsage\|export.*getRemainingQuota" src/lib/youtube/quota.ts
```

Verify quota costs are defined:
```bash
grep "playlists.list.*1" src/lib/youtube/quota.ts
```

Confirm database operations:
```bash
grep "db.insert\|db.select" src/lib/youtube/quota.ts
```
  </verify>
  <done>
Quota tracking utilities exist with defined costs for all YouTube API operations. Functions log usage to database and calculate remaining daily quota. Ready for integration with rate limiter and dashboard.
  </done>
</task>

</tasks>

<verification>
**Code structure check:**
```bash
# Verify all exports exist
grep -h "export" src/lib/rate-limiter.ts src/lib/youtube/client.ts src/lib/youtube/quota.ts

# Check Bottleneck import
grep "import.*Bottleneck" src/lib/rate-limiter.ts

# Check googleapis import
grep "import.*google.*googleapis" src/lib/youtube/client.ts

# Verify database imports
grep "import.*db" src/lib/youtube/client.ts src/lib/youtube/quota.ts
```

**Logic validation:**
- Rate limiter has reservoir: 10000, refreshInterval: 24h
- ETag caching checks database before API call
- 304 responses return cached data (not making new request)
- Quota costs match research documentation (list=1, insert/update/delete=50)

**No runtime test yet:** These utilities will be tested in Plan 04 when actually calling YouTube API.
</verification>

<success_criteria>
- Bottleneck rate limiter configured with 10,000 unit reservoir and 24-hour refresh
- callYouTubeAPI wrapper function tracks quota consumption per operation
- YouTube API client implements ETag caching with database storage
- 304 Not Modified responses return cached data without consuming quota
- Quota tracking utilities log operations to database
- getRemainingQuota calculates daily quota consumption from database
- All code compiles without TypeScript errors (run `npm run build`)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-api-integration/01-03-SUMMARY.md` using the summary template.
</output>
