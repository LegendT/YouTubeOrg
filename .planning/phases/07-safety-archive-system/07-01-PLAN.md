---
phase: 07-safety-archive-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - src/types/backup.ts
  - src/lib/backup/snapshot.ts
  - src/lib/backup/restore.ts
autonomous: true

must_haves:
  truths:
    - "operationLog and backupSnapshots tables exist in the database"
    - "Backup JSON structure uses stable identifiers (YouTube IDs, category names) not internal serial IDs"
    - "Snapshot creation writes JSON to filesystem and records metadata in backupSnapshots table"
    - "Restore reads JSON, verifies checksum integrity, and rebuilds category structure in a single transaction"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "operationLog and backupSnapshots table definitions"
      contains: "operationLog"
    - path: "src/types/backup.ts"
      provides: "BackupSnapshot, OperationLogEntry, PendingChange type definitions"
      min_lines: 40
    - path: "src/lib/backup/snapshot.ts"
      provides: "createSnapshot function that gathers data, writes JSON, records metadata"
      exports: ["createSnapshot"]
    - path: "src/lib/backup/restore.ts"
      provides: "restoreFromSnapshot function with integrity check and transactional restore"
      exports: ["restoreFromSnapshot"]
  key_links:
    - from: "src/lib/backup/snapshot.ts"
      to: "src/lib/db/schema.ts"
      via: "imports backupSnapshots, categories, categoryVideos, videos, mlCategorizations tables"
      pattern: "import.*schema"
    - from: "src/lib/backup/restore.ts"
      to: "src/lib/db/schema.ts"
      via: "imports categories, categoryVideos, videos, backupSnapshots for transactional restore"
      pattern: "db\\.transaction"
---

<objective>
Create the database schema, TypeScript types, and core backup/restore logic for the safety system.

Purpose: Establishes the foundation that all other Phase 7 plans build on — the tables for audit logging and backup metadata, the type system for backup data, and the core functions for creating and restoring JSON snapshots.

Output: Two new DB tables (operationLog, backupSnapshots) pushed to PostgreSQL, shared types, and two core library modules (snapshot.ts, restore.ts) in src/lib/backup/.
</objective>

<execution_context>
@/Users/anthonygeorge/.claude/get-shit-done/workflows/execute-plan.md
@/Users/anthonygeorge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-safety-archive-system/07-RESEARCH.md
@src/lib/db/schema.ts
@src/lib/db/index.ts
@src/types/categories.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add database tables and TypeScript types</name>
  <files>src/lib/db/schema.ts, src/types/backup.ts</files>
  <action>
**In src/lib/db/schema.ts**, add two new tables after the Phase 5 section, under a `// --- Phase 7: Safety & Archive System ---` comment:

1. `backupSnapshots` table:
   - `id: serial('id').primaryKey()`
   - `filename: text('filename').notNull().unique()` — the JSON file name in backups/
   - `trigger: text('trigger').notNull()` — what caused the backup: 'manual', 'pre_delete', 'pre_merge', 'pre_sync', 'pre_restore'
   - `scope: text('scope').notNull()` — 'full' or specific like 'category:Gaming'
   - `entityCount: integer('entity_count').notNull()` — total categories + videos in backup
   - `fileSizeBytes: integer('file_size_bytes').notNull()`
   - `checksum: text('checksum').notNull()` — SHA-256 hex digest for integrity verification
   - `createdAt: timestamp('created_at').notNull().defaultNow()`

2. `operationLog` table (append-only audit trail):
   - `id: serial('id').primaryKey()`
   - `action: text('action').notNull()` — e.g. 'delete_category', 'merge_categories', 'restore_backup', 'move_videos'
   - `entityType: text('entity_type').notNull()` — 'category', 'video', 'backup'
   - `entityIds: jsonb('entity_ids').$type<number[]>().notNull()` — affected entity IDs
   - `metadata: jsonb('metadata')` — action-specific detail (e.g. { categoryName, videoCount })
   - `backupSnapshotId: integer('backup_snapshot_id').references(() => backupSnapshots.id)` — linked pre-operation backup
   - `createdAt: timestamp('created_at').notNull().defaultNow()`

After adding, run `npx drizzle-kit push` to sync to PostgreSQL.

**Create src/types/backup.ts** with these types:

```typescript
// Backup JSON file structure — uses stable YouTube IDs and category names, NOT internal serial IDs
export interface BackupData {
  version: '1.0';
  createdAt: string;          // ISO 8601
  trigger: string;            // What triggered: 'manual', 'pre_delete', 'pre_merge', 'pre_sync', 'pre_restore'
  data: {
    categories: BackupCategory[];
    mlCategorizations: BackupMLCategorization[];
    metadata: {
      totalCategories: number;
      totalVideos: number;
      totalCategorizations: number;
    };
  };
}

export interface BackupCategory {
  name: string;
  isProtected: boolean;
  videos: BackupCategoryVideo[];
}

export interface BackupCategoryVideo {
  youtubeId: string;
  title: string;
  source: string;             // 'consolidation', 'manual', 'merge', 'orphan', 'undo', 'restore'
}

export interface BackupMLCategorization {
  videoYoutubeId: string;
  suggestedCategoryName: string;
  confidence: 'HIGH' | 'MEDIUM' | 'LOW';
  similarityScore: number;
  acceptedAt: string | null;
  rejectedAt: string | null;
  manualCategoryName: string | null;
}

// Operation log entry (mirrors DB row but typed)
export interface OperationLogEntry {
  id: number;
  action: string;
  entityType: string;
  entityIds: number[];
  metadata: Record<string, unknown> | null;
  backupSnapshotId: number | null;
  createdAt: Date;
}

// Backup snapshot metadata (mirrors DB row but typed)
export interface BackupSnapshotMeta {
  id: number;
  filename: string;
  trigger: string;
  scope: string;
  entityCount: number;
  fileSizeBytes: number;
  checksum: string;
  createdAt: Date;
}

// Pending change item for pre-sync review (SAFE-06)
export interface PendingChange {
  type: 'category_created' | 'category_deleted' | 'category_renamed' | 'videos_moved' | 'videos_added' | 'ml_accepted' | 'ml_rejected' | 'ml_recategorised';
  description: string;
  entityType: string;
  count: number;
  timestamp: Date;
}

export interface PendingChangeSummary {
  changes: PendingChange[];
  totalChanges: number;
  lastSyncTimestamp: Date | null;
}
```

Also add `backups/` to .gitignore if not already present.
  </action>
  <verify>
Run `npx drizzle-kit push` — should succeed with 2 new tables created.
Run `npx tsx -e "import { operationLog, backupSnapshots } from './src/lib/db/schema'; console.log('Tables:', Object.keys(operationLog), Object.keys(backupSnapshots))"` — should print table column info without errors.
Check that src/types/backup.ts compiles: `npx tsc --noEmit src/types/backup.ts` or verify no red squiggles.
  </verify>
  <done>
operationLog and backupSnapshots tables exist in PostgreSQL. BackupData, OperationLogEntry, BackupSnapshotMeta, PendingChange types exported from src/types/backup.ts. backups/ added to .gitignore.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create backup snapshot and restore core logic</name>
  <files>src/lib/backup/snapshot.ts, src/lib/backup/restore.ts</files>
  <action>
**Create src/lib/backup/snapshot.ts** — the core function for creating JSON backup files:

1. `createSnapshot(trigger: string, scope: string = 'full')` function:
   - Query all categories from `categories` table
   - Query all categoryVideos joined with videos to get youtubeId and title
   - Query all mlCategorizations joined with videos (for youtubeId) and categories (for category name), including acceptance/rejection state
   - Group videos by category using the category name (not ID) as the key
   - Build a `BackupData` object using the interface from src/types/backup.ts
   - Generate filename: `backup-${trigger}-${ISO timestamp with colons/dots replaced by dashes}.json`
   - Write JSON (pretty-printed with 2-space indent) to `backups/` directory (create dir with `recursive: true`)
   - Compute SHA-256 checksum of the JSON string
   - Insert row into `backupSnapshots` table with filename, trigger, scope, entityCount (categories + unique videos), fileSizeBytes (Buffer.byteLength), checksum
   - Return `{ snapshotId: number, filename: string, createdAt: Date }`

   Import `promises as fs` from 'fs', `path`, `createHash` from 'crypto', `db` from '@/lib/db', and relevant schema tables.

   IMPORTANT: Use `Number()` wrapper on any count() aggregates per MEMORY.md BigInt rule. Use YouTube IDs and category names as identifiers in backup JSON, NOT internal serial IDs.

2. `gatherSnapshotData(scope: string)` internal helper:
   - For 'full' scope: gather all categories and all their video assignments
   - For category-specific scope (e.g. 'category:Gaming'): gather only that category's data
   - Returns the `data` portion of `BackupData`

**Create src/lib/backup/restore.ts** — the core function for restoring from a backup:

1. `restoreFromSnapshot(snapshotId: number)` function:
   - Look up backupSnapshots row by ID
   - If not found, return `{ success: false, error: 'Backup not found' }`
   - Read the JSON file from `backups/` directory
   - Verify SHA-256 checksum matches stored checksum. If mismatch, return `{ success: false, error: 'Backup integrity check failed — file may be corrupted' }`
   - Parse JSON into BackupData
   - **Create a pre-restore backup first** by calling `createSnapshot('pre_restore')` — safety net
   - Execute restore in a **single Drizzle transaction** (`db.transaction(async (tx) => { ... })`):
     a. Delete all rows from categoryVideos
     b. Delete all non-protected categories (`where(eq(categories.isProtected, false))`)
     c. For the protected "Uncategorised" category: keep it, but also restore its video assignments from backup
     d. For each category in backup.data.categories:
        - If `isProtected: true`, look up existing protected category by name
        - Otherwise, insert new category with `name`, `isProtected: false`, `videoCount: cat.videos.length`
        - For each video in the category, look up the video by `youtubeId` in the videos table, then insert into categoryVideos with the new category ID
     e. Optionally restore mlCategorizations if present (look up video by youtubeId, category by name)
   - Return `{ success: true, preRestoreBackupId: number }` with the ID of the safety backup

   IMPORTANT: Use `eq(videos.youtubeId, video.youtubeId)` for video lookup — never assume internal IDs match. Handle missing videos gracefully (skip with warning, don't fail the whole restore).
  </action>
  <verify>
Files compile without TypeScript errors. Run `npx tsc --noEmit` on the project.
Manually verify that snapshot.ts exports `createSnapshot` and restore.ts exports `restoreFromSnapshot`.
Check that the backup directory constant uses `path.join(process.cwd(), 'backups')`.
  </verify>
  <done>
createSnapshot function gathers all category/video/ML data, writes JSON to backups/ directory, records metadata in backupSnapshots table, and returns snapshot ID. restoreFromSnapshot function reads backup JSON, verifies checksum, creates safety backup, and restores category structure in a single DB transaction using YouTube IDs for video lookup.
  </done>
</task>

</tasks>

<verification>
- `npx drizzle-kit push` succeeds — operationLog and backupSnapshots tables created in PostgreSQL
- `npx tsc --noEmit` — no TypeScript compilation errors across the project
- src/types/backup.ts exports BackupData, OperationLogEntry, BackupSnapshotMeta, PendingChange, PendingChangeSummary
- src/lib/backup/snapshot.ts exports createSnapshot
- src/lib/backup/restore.ts exports restoreFromSnapshot
- backups/ directory in .gitignore
</verification>

<success_criteria>
Phase 7 foundation is in place: database schema for audit logging and backup metadata, TypeScript type system for backup data, and core backup/restore functions ready for server actions to consume.
</success_criteria>

<output>
After completion, create `.planning/phases/07-safety-archive-system/07-01-SUMMARY.md`
</output>
