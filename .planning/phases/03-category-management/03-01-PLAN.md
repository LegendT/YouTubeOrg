---
phase: 03-category-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - src/types/categories.ts
  - scripts/migrate-proposals-to-categories.ts
autonomous: true

must_haves:
  truths:
    - "categories and categoryVideos tables exist in PostgreSQL"
    - "Approved proposals are converted into categories with video associations"
    - "Uncategorized category exists as a safety net for orphaned videos"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "categories and categoryVideos table definitions"
      contains: "export const categories"
    - path: "src/types/categories.ts"
      provides: "Phase 3 type definitions for Category, CategoryVideo, undo data"
      exports: ["Category", "CategoryVideo", "DeleteUndoData", "MergeUndoData"]
    - path: "scripts/migrate-proposals-to-categories.ts"
      provides: "One-time migration converting finalized proposals to categories"
  key_links:
    - from: "src/lib/db/schema.ts"
      to: "categories table"
      via: "pgTable definition"
      pattern: "pgTable\\('categories'"
    - from: "src/lib/db/schema.ts"
      to: "categoryVideos table"
      via: "pgTable definition with foreign keys"
      pattern: "pgTable\\('category_videos'"
    - from: "scripts/migrate-proposals-to-categories.ts"
      to: "src/lib/db/schema.ts"
      via: "imports categories, categoryVideos, consolidationProposals"
      pattern: "import.*from.*schema"
---

<objective>
Create the Phase 3 data model: new `categories` and `category_videos` tables, Phase 3 type definitions, and a migration script that converts finalized Phase 2 proposals into proper categories with individual video tracking.

Purpose: Phase 2 used `consolidationProposals` with playlist-level JSONB for analysis. Phase 3 needs a proper many-to-many relationship between categories and individual videos to support move/copy, orphan detection, deduplication, and CRUD operations.

Output: New DB tables pushed via `drizzle-kit push`, type definitions, and a runnable migration script that populates categories from approved proposals.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-category-management/03-CONTEXT.md
@.planning/phases/03-category-management/03-RESEARCH.md

@src/lib/db/schema.ts
@src/lib/db/index.ts
@src/types/analysis.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add categories and categoryVideos tables to schema + create Phase 3 types</name>
  <files>
    src/lib/db/schema.ts
    src/types/categories.ts
  </files>
  <action>
Add two new tables to the BOTTOM of `src/lib/db/schema.ts` (below the existing Phase 2 tables), under a `// --- Phase 3: Category Management ---` comment:

1. **`categories` table:**
   - `id`: serial primary key
   - `name`: text, not null
   - `sourceProposalId`: integer, nullable, references `consolidationProposals.id` (tracks origin for traceability)
   - `videoCount`: integer, not null, default 0 (denormalized for fast list rendering -- avoids COUNT joins)
   - `isProtected`: boolean (use `import { boolean } from 'drizzle-orm/pg-core'`), not null, default false (true for "Uncategorized" -- prevents rename/delete)
   - `createdAt`: timestamp, not null, defaultNow
   - `updatedAt`: timestamp, not null, defaultNow

2. **`categoryVideos` table:**
   - `id`: serial primary key
   - `categoryId`: integer, not null, references `categories.id` with `{ onDelete: 'cascade' }`
   - `videoId`: integer, not null, references `videos.id`
   - `addedAt`: timestamp, not null, defaultNow
   - `source`: text, default 'consolidation' (values: 'consolidation', 'manual', 'merge', 'orphan', 'undo')

Import `boolean` from `drizzle-orm/pg-core` in the existing import statement at the top of schema.ts.

Then create `src/types/categories.ts` with these type definitions:

```typescript
export interface Category {
  id: number;
  name: string;
  sourceProposalId: number | null;
  videoCount: number;
  isProtected: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export interface CategoryVideo {
  id: number;
  categoryId: number;
  videoId: number;
  addedAt: Date;
  source: string;
}

export interface CategoryListItem {
  id: number;
  name: string;
  videoCount: number;
  isProtected: boolean;
  sourcePlaylistNames: string[];
  updatedAt: Date;
}

export interface DeleteUndoData {
  type: 'delete';
  categoryName: string;
  categoryId: number;
  videoIds: number[];
  wasProtected: boolean;
}

export interface MergeUndoData {
  type: 'merge';
  mergedCategoryId: number;
  originalCategories: Array<{
    name: string;
    videoIds: number[];
  }>;
}

export type UndoData = DeleteUndoData | MergeUndoData;

export interface CategoryActionResult {
  success: boolean;
  error?: string;
}

export interface DeleteCategoryResult extends CategoryActionResult {
  undoData?: DeleteUndoData;
  orphanedCount?: number;
}

export interface MergeCategoriesResult extends CategoryActionResult {
  mergedCategoryId?: number;
  totalVideos?: number;
  undoData?: MergeUndoData;
}

export interface VideoSearchResult {
  id: number;
  youtubeId: string;
  title: string;
  thumbnailUrl: string | null;
  channelTitle: string | null;
  duration: string | null;
  categoryNames: string[];
}
```
  </action>
  <verify>
Run `npx drizzle-kit push` to push the new tables to PostgreSQL. Verify no errors. Then run `npx tsc --noEmit` to confirm type definitions compile cleanly.
  </verify>
  <done>
`categories` and `category_videos` tables exist in PostgreSQL (confirmed by drizzle-kit push). `src/types/categories.ts` exports all Phase 3 types. TypeScript compiles with no errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create migration script to convert finalized proposals to categories</name>
  <files>
    scripts/migrate-proposals-to-categories.ts
  </files>
  <action>
Create a `scripts/migrate-proposals-to-categories.ts` script that runs via `npx tsx scripts/migrate-proposals-to-categories.ts`. This is a one-time data migration. The script must:

1. **Check prerequisites:**
   - Query `analysisSessions` for a row with `finalizedAt IS NOT NULL`. If none found, exit with message "No finalized session found. Run Phase 2 finalization first."
   - Query `categories` table -- if rows already exist, exit with message "Categories already migrated. Skipping." (idempotent safety).

2. **Create "Uncategorized" category FIRST:**
   - Insert into `categories` with `name: 'Uncategorized'`, `isProtected: true`, `videoCount: 0`, `sourceProposalId: null`.

3. **Migrate approved proposals to categories:**
   - Query all `consolidationProposals` with `status = 'approved'`.
   - For each proposal:
     a. Insert into `categories` with `name: proposal.categoryName`, `sourceProposalId: proposal.id`, `isProtected: false`.
     b. Get the new category ID from the returning clause.
     c. Query `playlistVideos` for all video IDs belonging to the proposal's `sourcePlaylistIds` (the JSONB array of playlist DB IDs).
     d. Deduplicate video IDs (a video may appear in multiple source playlists).
     e. Batch insert into `categoryVideos` with `categoryId: newCategoryId`, `videoId`, `source: 'consolidation'`.
     f. Update `categories.videoCount` to the deduplicated count.

4. **Handle orphaned videos:**
   - After all proposals are migrated, find any videos in the `videos` table that do NOT appear in `categoryVideos`.
   - Insert those into `categoryVideos` with `categoryId` = the Uncategorized category, `source: 'orphan'`.
   - Update Uncategorized's `videoCount`.

5. **Print summary:**
   - "Migrated X categories with Y total video assignments"
   - "Z orphaned videos assigned to Uncategorized"

Use `db.transaction()` to wrap the entire migration atomically. Import the db connection from `@/lib/db` -- but since this runs outside Next.js, you need to handle the module resolution. Use a direct import: `import { db } from '../src/lib/db'` or configure tsx with tsconfig paths. Check `tsconfig.json` for path aliases and use the appropriate import approach.

Remember: PostgreSQL `count()` returns strings via Drizzle. Wrap with `Number()` where needed.
  </action>
  <verify>
Run `DATABASE_URL=$(grep DATABASE_URL .env.local | cut -d= -f2-) npx tsx scripts/migrate-proposals-to-categories.ts` and verify:
1. Output shows "Migrated N categories with M total video assignments"
2. Query the database: `SELECT count(*) FROM categories` returns > 0
3. Run the script again -- should print "Categories already migrated. Skipping." (idempotent)
  </verify>
  <done>
Migration script successfully converts finalized Phase 2 proposals into `categories` rows with associated `categoryVideos`. "Uncategorized" category exists with `isProtected: true`. Script is idempotent (safe to re-run). Video counts are accurate.
  </done>
</task>

</tasks>

<verification>
1. `npx drizzle-kit push` succeeds with new tables
2. `npx tsc --noEmit` passes with zero errors
3. Migration script runs and populates categories + categoryVideos
4. Uncategorized category exists with isProtected = true
5. Video counts on categories match actual categoryVideos counts
</verification>

<success_criteria>
- categories table has rows matching approved proposals + 1 Uncategorized
- categoryVideos table has rows for every video in every approved proposal's source playlists (deduplicated per category)
- Types in src/types/categories.ts compile and export all needed interfaces
- Migration script is idempotent
</success_criteria>

<output>
After completion, create `.planning/phases/03-category-management/03-01-SUMMARY.md`
</output>
